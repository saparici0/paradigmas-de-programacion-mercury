<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Programación Concurrente UNAL</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="" name="keywords" />
    <meta content="" name="description" />

    <!-- Favicons -->
    <link href="images/favicon.ico" rel="icon" />

    <!-- Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,700,700i|Poppins:300,400,500,700"
      rel="stylesheet"
    />

    <!-- Bootstrap CSS File -->
    <link href="lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />

    <!-- Libraries CSS Files -->
    <link href="lib/font-awesome/css/font-awesome.min.css" rel="stylesheet" />
    <link href="lib/animate/animate.min.css" rel="stylesheet" />

    <!-- Main Stylesheet File -->
    <link href="stylesheets/style.css" rel="stylesheet" />

    <!-- PrettyPrint CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css" rel="stylesheet">

    <!-- PrettyPrint JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>

  </head>

  <body>
    <header id="header">
      <div class="container">
        <div id="logo" class="pull-left">
          <a><img src="images/logo.png" class="resize" /></a>
        </div>

        <nav id="nav-menu-container">
          <ul class="nav-menu">
            <li class="menu-has-children"><a href="index.html#hero">Programación concurrente</a>
              <ul>
                  <li><a href="index.html#definicion">¿Qué es?</a></li>
                  <li><a href="index.html#filosofia">Filosofía del paradigma</a></li>
                  <li><a href="index.html#historia">Historia</a></li>
                  <li><a href="index.html#concurvsparal">Concurrencia vs paralelismo</a></li>
                  <li><a href="index.html#conceptos">Conceptos</a></li>
                  <li><a href="index.html#ventajas">Ventajas</a></li>
                  <li><a href="index.html#desventajas">Desventajas</a></li>
              </ul>
            </li>
      
            <li class="menu-active menu-has-children"><a href="lenguajes.html">Lenguajes</a>
              <ul>
                <li><a href="lenguajes.html#elixir">Elixir</a></li>
                <li><a href="lenguajes.html#ada">Ada</a></li>
                <li><a href="lenguajes.html#rust">Rust</a></li>
                <li><a href="lenguajes.html#erlang">Erlang</a></li>
                <li><a href="lenguajes.html#go">Go</a></li>
                <li><a href="lenguajes.html#haskel">Haskel</a></li>
                <li><a href="lenguajes.html#crystal">Crystal</a></li>
                <li><a href="lenguajes.html#javal">Java</a></li>
                <li><a href="lenguajes.html#python">Python</a></li>
                <li><a href="lenguajes.html#c">C</a></li>
                <li><a href="lenguajes.html#ejemplosLenguajes">Ejemplos</a></li>
                <li><a href="lenguajes.html#ejemploComparativo">Ejemplo Comparativo</a></li>
              </ul>
            </li>
            <li class="menu-has-children"><a href="index.html#aplicaciones">Aplicaciones</a>
              <ul>
                <li><a href="index.html#aplicaciones">Aplicaciones generales</a></li>
                <li><a href="index.html#aplicacionesReales">Aplicaciones reales</a></li>
              </ul>
            </li>
            <li><a href="quiz/index.html">Quiz</a></li>
            <li class="menu-has-children"><a href="references.html">Referencias</a>
              <ul>
                  <li><a href="references.html#referencias">Referencias</a></li>
                  <li><a href="references.html#integrantes">Integrantes</a></li>
                  <li><a href="references.html#presentacion">Presentaciones</a></li>
                </ul>
          </li>
          </ul>
        </nav><!-- #nav-menu-container -->
      </div>
    </header>
    <!-- #header -->

    <main id="main">
      <br /><br />
      <br /><br />
      <section id="lenguajes" style="margin-top: 50px">
        <div class="container">
            <div class="text_cell_render border-box-sizing rendered_html">
                <h2 class="title"><strong>Lenguajes</strong></h2>

                <!-- Ada -->
                <div id="ada">
                    <h3><strong>Ada</strong></h3>
                    <center>
                        <img src="images/ada-coin.jpg" width="150px" height="150px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> Ada es un lenguaje nacido de un proyecto en los 70s del ejército de los Estados Unidos, con la principal prioridad en la seguridad y la minimización de errores.
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> Sincroniza las tareas por rendez vous.
                    </p>
                    <p>
                        <strong>Herramientas para aprovechar la concurrencia:</strong> Amplio uso en la industria de las infraestructuras de riesgo grande, como sistemas de aviones, trenes, tanques y misiles.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> Sistemas de planeación aérea y naval.
                    </p>
                </div>
                <br />

                <!-- Haskell -->
                <div id="haskell">
                    <h3><strong>Haskell</strong></h3>
                    <center>
                        <img src="images/haskell.png" width="150px" height="150px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> Haskell es un lenguaje polimórficamente tipificado, perezoso, puramente funcional, muy diferente a la mayoría de los otros lenguajes de programación.
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> La concurrencia es "ligera", lo que significa que tanto la creación de hilos como los gastos generales de cambio de contexto son extremadamente bajos.
                    </p>
                    <p>
                        <strong>Herramientas para aprovechar la concurrencia:</strong> La programación de los hilos de Haskell se hace internamente y no hace uso de ningún paquete de hilos suministrado por el sistema operativo.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> Análisis de sintaxis en código alojado en GitHub.
                    </p>
                </div>
                <br />

                <!-- Erlang -->
                <div id="erlang">
                    <h3><strong>Erlang</strong></h3>
                    <center>
                        <img src="images/erlang.png" width="150px" height="150px" />
                    </center>
                    <p>
                        <strong>Historia:</strong>  Creado por Ericsson en 1986 con el propósito de desarrollar sistemas de telecomunicaciones. Diseñado para soportar numerosos procesos concurrentes. Liberado como software libre en 1998. A llevado al desarrollo de otros lenguajes que priorizan la concurrencia.
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> Modelo de concurrencia basado en actores, esto quiere decir que cuenta con procesos aislados que no comparten memoria, estos procesos se comunican a través de mensajes y son procesos ligeros gestionados por la máquina virtual BEAM. 
                    </p>
                    <p>
                        <strong>Herramientas para aprovechar la concurrencia:</strong> Erlang ofrece diversas herramientas y bibliotecas que facilitan la gestión de la concurrencia y la construcción de sistemas distribuidos. La principal de estas es OTP (Open Telecom Platform) que proporciona componentes como supervisores, gen_servers, y otros patrones de diseño que facilitan la gestión de la concurrencia y la tolerancia a fallos. 
                        <ul>
                          <li>Supervisores: Procesos especiales que supervisan otros procesos</li>
                          <li>Gen_servers: Gestionan el ciclo de vida de los procesos y la comunicación entre ellos.</li>
                        </ul>
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> Lógica de negocio de aplicaciones como WhatsApp.
                    </p>
                </div>
                <br />

                <!-- Elixir -->
                <div id="elixir">
                    <h3><strong>Elixir</strong></h3>
                    <center>
                        <img src="images/elixir.png" width="150px" height="150px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> Elixir es un lenguaje de programación de propósito general, concurrente y funcional. Comenzó en 2011 con el objetivo de aprovechar la robustez y el rendimiento de Erlang y su máquina virtual, introduciendo características y mejoras que hicieran el lenguaje más productivo para los desarrolladores modernos, lo que lo ha hecho popular en el entorno de desarrollo web.
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> Al igual que Erlang, Elixir se basa en el modelo de actores y aprovecha la máquina virtual BEAM, ofreciendo aislamiento de procesos, comunicación mediante mensajes y la ligereza de los procesos.
                    </p>
                    <p>
                        <strong>Herramientas para aprovechar la concurrencia:</strong> Además de las herramientas OTP, podemos encontrar Phoenix Web Framework, capaz de manejar un alto tráfico concurrente y adecuado para aplicaciones con notificaciones en tiempo real; Task, para ejecutar funciones de forma concurrente; y Agent, para gestionar el estado compartido entre procesos.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> Changelog, una plataforma de podcasts para desarrolladores.
                    </p>
                </div>
                <br />

                <!-- Rust -->
                <div id="rust">
                    <h3><strong>Rust</strong></h3>
                    <center>
                        <img src="images/rust.png" width="150px" height="150px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> Rust es un lenguaje de programación compilado, de propósito general y multiparadigma. Patrocinado por Mozilla desde 2009, Rust tiene como propósito ofrecer seguridad en memoria y concurrencia, diseñado específicamente para evitar problemas comunes como condiciones de carrera, desbordamiento de búfer y violaciones de acceso a memoria.
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> En el modelo de propiedad y préstamos de Rust, la propiedad asegura que solo un propietario pueda modificar un valor a la vez, mientras que los préstamos permiten el acceso seguro a datos compartidos. En cuanto a los tipos de concurrencia, Rust soporta concurrencia basada en hilos (threads) y basada en tareas asíncronas. Además, proporciona seguridad en la concurrencia al verificar las condiciones de seguridad en tiempo de compilación.
                    </p>
                    <p>
                        <strong>Herramientas para aprovechar la concurrencia:</strong> En Rust, std::thread permite crear y gestionar hilos de manera segura, mientras que std::sync proporciona primitivas de sincronización para manejar el acceso concurrente a los datos. Además, las funciones async/await facilitan la escritura de código asíncrono y concurrente.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> Partes del kernel de Linux, cuya escritura es soportada desde octubre de 2022.
                    </p>
                </div>
                <br />

                <!-- GO -->
                <div id="go">
                    <h3><strong>GO</strong></h3>
                    <center>
                        <img src="images/go.png" width="150px" height="150px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> Diseñado en Google en 2007, Go (también conocido como Golang) tenía como objetivo combinar lo mejor de los lenguajes compilados, como la eficiencia y la seguridad, con las ventajas de los lenguajes interpretados, como la facilidad de uso y la productividad. Hoy en día, Go es popular en sistemas distribuidos, microservicios y aplicaciones en la nube
                    </p>
                    <p>
                        <strong>Concurrencia y herramientas en el lenguaje:</strong> En Go, las goroutines son funciones que se ejecutan concurrentemente en el mismo espacio de direcciones y son gestionadas por el runtime de Go. Los canales permiten la comunicación y sincronización entre goroutines, pudiendo ser sincrónicos o asincrónicos.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> El código backend de Uber.
                    </p>
                </div>
                <br />

                <!-- Crystal -->
                <div id="crystal">
                    <h3><strong>Crystal</strong></h3>
                    <center>
                        <img src="images/crystal.png" width="150px" height="150px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> Crystal es uno de los nuevos lenguajes en la escena, iniciado en 2012. Tiene una sintaxis similar a Ruby, estáticamente tipado, compilado y es self-hosted (Crystal está escrito en Crystal).
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> Crystal viene con una primitiva de concurrencia llamada fibras, que son básicamente una versión más ligera de hilos. Las otras primitivas de concurrencia son canales.
                    </p>
                    <p>
                        <strong>Herramientas para aprovechar la concurrencia:</strong> Utiliza canales para la concurrencia, similar a Go.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> Servicios web de compañías como Errordeck, GigSmart, Appmonitor, etc.
                    </p>
                </div>
                <br />

                <!-- Java -->
                <div id="java">
                    <h3><strong>Java</strong></h3>
                    <center>
                        <img src="images/java.png" width="200px" height="150px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> Java es un lenguaje de programación orientado a objetos creado en 1991 y publicado en 1995 por Sun Microsystem (adquirida por Oracle en 2010), con la intención de que los programadores escribieran el código solo una vez y lo ejecutaran en cualquier dispositivo.
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> Java permite realizar concurrencia con la librería threads. Además, cuenta con otras librerías que implementan métodos de planificación y control de procesos (variables atómicas, semáforos, entre otros) traídos del paquete concurrent.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> Innumerables. Desde servicios web backend mediante Spring Boot hasta desarrollo de videojuegos con LWJGL, la librería usada para escribir Minecraft.
                    </p>
                </div>
                <br />

                <!-- Python -->
                <div id="python">
                    <h3><strong>Python</strong></h3>
                    <center>
                        <img src="images/python.png" width="96px" height="96px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> Python es el lenguaje más utilizado a nivel mundial (según revista IEEE). Es un lenguaje de sintaxis simple y cubre una gran cantidad de áreas del conocimiento como inteligencia artificial y ciencia de datos.
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> Cuenta con varias librerías para la implementación de programación concurrente y su respectivo control, como lo son la librería "Thread" y "Multiprocessing".
                    </p>
                    <p>
                        <strong>Herramientas para aprovechar la concurrencia:</strong> La librería "Thread" incluye una interfaz de alto nivel orientada a objetos para trabajar con concurrencia desde Python. Los objetos Thread se ejecutan al mismo tiempo dentro del mismo proceso y comparten memoria.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> El backend de Instagram.
                    </p>
                </div>
                <br />

                <!-- C -->
                <div id="c">
                    <h3><strong>C</strong></h3>
                    <center>
                        <img src="images/c.jpg" width="180px" height="96px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> C es uno de los lenguajes más rápidos que existen puesto a que es un lenguaje compilado. Es altamente usado en el diseño y desarrollo de los sistemas operativos que hoy en día se usan.
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> En cuanto a programación concurrente, usa la librería pthread.h para la creación de hilos y métodos de control muy básicos como la implementación de un semáforo.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> El kernel de Linux y otros lenguajes como Python y C++.
                    </p>
                </div>
                <br />

                <!-- C++ -->
                <div id="c++">
                    <h3><strong>C++</strong></h3>
                    <center>
                        <img src="images/cpp.png" width="96px" height="96px" />
                    </center>
                    <p>
                        <strong>Historia:</strong> Fue diseñado a mediados de los años 80 por el danés Bjarne Stroustrup. Su intención fue la de extender el lenguaje de programación C para que tuviese los mecanismos necesarios para manipular objetos.
                    </p>
                    <p>
                        <strong>Concurrencia en el lenguaje:</strong> C++ contiene los paradigmas de la programación estructurada y orientada a objetos. Se puede usar una librería thread que es básicamente una sección de código independiente que el procesador puede ejecutar de forma concurrente junto a otros threads o hilos de ejecución.
                    </p>
                    <p>
                        <strong>Aplicaciones notables:</strong> Motores gráficos como Source de Valve, usado en videojuegos como Half-Life y Counter-Strike.
                    </p>
                </div>
            </div>
        </div>
      </section>

      <section id="ejemplosLenguajes" style="margin-top:50px;">
        <div class="container">
          <div class="text_cell_render border-box-sizing rendered_html">
            <h2 class="title"><strong>Ejemplos Lenguages</strong></h2>
  
              <ul>
                <li>Ejemplo en <strong>python</strong>: Este es un pequeño ejemplo con el fin de ilustrar como podemos
                  lanzar un hilo en python</li>
              </ul>
  
              <div class="highlight highlight-source-python">
                <pre><span class="pl-k">from</span> threading <span class="pl-k">import</span> Thread
  <span class="pl-k">import</span> time
  
  <span class="pl-k">def</span> <span class="pl-en">say_hello</span>(<span class="pl-smi">name</span>):
      <span class="pl-c1">print</span> (name, <span class="pl-s"><span class="pl-pds">"</span>Hola<span class="pl-pds">"</span></span>)
  
  t <span class="pl-k">=</span> Thread(<span class="pl-v">target</span><span class="pl-k">=</span>say_hello, <span class="pl-v">args</span><span class="pl-k">=</span>(<span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>,))
  t.start()
  t.join()</pre>
              </div>
  
              <p><strong>Ejecucion:</strong> python archivo.py</p>
  
              <blockquote>
                <p>('world', 'Hola')</p>
              </blockquote>
  
              <ul>
                <li>Ejemplo en <em>GO</em>: En este ejemplo podemos visualizar que los hilos no se ejecutan en el orden
                  ascedente si no esto lo decide el scheduler del sistema operativo</li>
              </ul>
  
              <div class="highlight highlight-source-go">
                <pre><span class="pl-k">package</span> main
  
  <span class="pl-k">import</span> (
      <span class="pl-s"><span class="pl-pds">"</span>fmt<span class="pl-pds">"</span></span>
      <span class="pl-s"><span class="pl-pds">"</span>time<span class="pl-pds">"</span></span>
  )
  
  <span class="pl-k">const</span> <span class="pl-v">FINAL</span> = <span class="pl-c1">100</span> * time.<span class="pl-smi">Millisecond</span>
  
  <span class="pl-k">func</span> <span class="pl-en">saluda</span>(<span class="pl-v">i</span> <span class="pl-v">int</span>) {
      time.<span class="pl-c1">Sleep</span>(<span class="pl-c1">10</span> * time.<span class="pl-c1">Duration</span>(i%<span class="pl-c1">5</span>) * time.<span class="pl-smi">Millisecond</span> )
      fmt.<span class="pl-c1">Println</span>(<span class="pl-s"><span class="pl-pds">"</span>Hola a todos<span class="pl-pds">"</span></span>, i)
  }
  
  <span class="pl-k">func</span> <span class="pl-en">main</span>() {
      <span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">:=</span> <span class="pl-c1">1</span>; i &lt;= <span class="pl-c1">6</span>; i++ {
          <span class="pl-c">// Lanzamos nuestro hilo solo anteponiendo la palabra go a la funcion</span>
          <span class="pl-k">go</span> <span class="pl-c1">saluda</span>(i)
      }
      time.<span class="pl-c1">Sleep</span>(FINAL)
  }</pre>
              </div>
  
              <p><strong>Ejecucion:</strong> go run archivo.go</p>
  
              <blockquote>
                <p>Hola a todos 5</p>
  
                <p>Hola a todos 6</p>
  
                <p>Hola a todos 1</p>
  
                <p>Hola a todos 2</p>
  
                <p>Hola a todos 3</p>
  
                <p>Hola a todos 4</p>
              </blockquote>
  
              <ul>
                <li>Ejemplos semaforo en <strong>C</strong>: El siguiente codigo fuente solo sirve sistemas operativos
                  basado en unix.</li>
              </ul>
  
              <div class="highlight highlight-source-c">
                <pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdlib.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>pthread.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>unistd.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>sys/types.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>fcntl.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>sys/stat.h<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>semaphore.h<span class="pl-pds">&gt;</span></span>
  
  #<span class="pl-k">define</span> <span class="pl-en">NUMHILOS</span> <span class="pl-c1">5</span>
  
  <span class="pl-c1">sem_t</span> *semaforo;
  <span class="pl-k">int</span> error, i, parametro, a;
  <span class="pl-k">char</span> t;
  <span class="pl-k">void</span> *z;
  
  <span class="pl-k">void</span> *<span class="pl-en">fun</span>(<span class="pl-k">void</span> *ap )
  {
      <span class="pl-c1">sem_t</span> *sem = ap;
      <span class="pl-k">char</span> t;
      <span class="pl-c1">sem_wait</span>( sem ); <span class="pl-c">// Bloqueamos seccion critica</span>
      <span class="pl-c1">printf</span>( <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span> Hilo ENTRO a seccion critica<span class="pl-pds">"</span></span> );
      <span class="pl-c1">fflush</span>( stdout );
      <span class="pl-c1">sleep</span>( <span class="pl-c1">1</span> );
      <span class="pl-c1">printf</span>( <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span> Hilo SALIO a seccion critica<span class="pl-cce">\n\n</span><span class="pl-pds">"</span></span> );
      <span class="pl-c1">fflush</span>( stdout );
      <span class="pl-c1">sem_post</span>( sem ); <span class="pl-c">// Desbloqueamos seccion critica</span>
  }
  
  <span class="pl-k">int</span> <span class="pl-en">main</span>()
  {
      <span class="pl-c">// Creamos nuestro semaforo</span>
      semaforo = <span class="pl-c1">sem_open</span>( <span class="pl-s"><span class="pl-pds">"</span>sema<span class="pl-pds">"</span></span>, O_CREAT, <span class="pl-c1">0666</span>, <span class="pl-c1">1</span> );
  
      <span class="pl-c">// Declaramos el descritor de los hilos</span>
      <span class="pl-c1">pthread_t</span> hilos[NUMHILOS];
  
      <span class="pl-c">// Creamos nuestros hilos</span>
      <span class="pl-k">for</span>( i = <span class="pl-c1">0</span>; i &lt; NUMHILOS; i++ )
          <span class="pl-c1">pthread_create</span>( &amp;hilos[i], <span class="pl-c1">NULL</span>, (<span class="pl-k">void</span> *)fun, semaforo );
  
      <span class="pl-c">// Esperamos a que nuestro hilos de ejecutan antes de terminar el programa</span>
      <span class="pl-k">for</span>( i = <span class="pl-c1">0</span>; i &lt; NUMHILOS; i++ )
          <span class="pl-c1">pthread_join</span>( hilos[i], (<span class="pl-k">void</span> *)&amp;z );
  
      <span class="pl-c">// Destruimos nuestro semaforo</span>
      <span class="pl-c1">sem_unlink</span>( <span class="pl-s"><span class="pl-pds">"</span>sema<span class="pl-pds">"</span></span> );
      <span class="pl-c1">sem_close</span>( semaforo );
      <span class="pl-k">return</span> <span class="pl-c1">0</span>;
  }</pre>
              </div>
  
              <p>Compilamos: <strong>gcc semaforo.c -o semaforo -pthread</strong></p>
  
              <p>Ejecutamos: <strong>./semaforo</strong></p>
  
              <blockquote>
                <p>Hilo ENTRO a sección critica</p>
  
                <p>Hilo SALIO a sección critica</p>
  
                <p>Hilo ENTRO a sección critica</p>
  
                <p>Hilo SALIO a sección critica</p>
  
                <p>Hilo ENTRO a sección critica</p>
  
                <p>Hilo SALIO a sección critica</p>
              </blockquote>
  
              <ul>
                <li>Ejemplo en <strong>C++</strong>: Calculamos el numero pi con 4 hilos con la ayuda de <a
                    href="https://es.wikipedia.org/wiki/Serie_de_Leibniz">Serie de Leibniz</a> </li>
              </ul>
  
              <div class="highlight highlight-source-c++">
                <pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>thread<span class="pl-pds">&gt;</span></span>
  #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>
  
  <span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
  vector&lt;<span class="pl-k">double</span>&gt; <span class="pl-en">valorCal</span>( <span class="pl-c1">4</span>, <span class="pl-c1">0.0</span> ), limites;
  
  <span class="pl-k">void</span> <span class="pl-en">calcularIntervalo</span> (<span class="pl-k">int</span> index)
  {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i = limites[<span class="pl-c1">index</span>]; i &lt; limites[<span class="pl-c1">index</span>+<span class="pl-c1">1</span>]; i++)
          <span class="pl-k">if</span> (i % <span class="pl-c1">2</span> == <span class="pl-c1">0</span>)
              valorCal[<span class="pl-c1">index</span>] += <span class="pl-c1">1.0</span>/(<span class="pl-c1">2</span>*i+<span class="pl-c1">1</span>);
          <span class="pl-k">else</span>
              valorCal[<span class="pl-c1">index</span>] -= <span class="pl-c1">1.0</span>/(<span class="pl-c1">2</span>*i+<span class="pl-c1">1</span>);
  }
  
  <span class="pl-k">int</span> <span class="pl-en">main</span>()
  {
      <span class="pl-c">// Creamos nuestro limites</span>
      <span class="pl-k">int</span> numeroSerie = <span class="pl-c1">1000000000</span>;
      limites.<span class="pl-c1">push_back</span>( <span class="pl-c1">0</span> );
      limites.<span class="pl-c1">push_back</span>( numeroSerie/<span class="pl-c1">4</span> );
      limites.<span class="pl-c1">push_back</span>( numeroSerie/<span class="pl-c1">2</span> );
      limites.<span class="pl-c1">push_back</span>( <span class="pl-c1">3</span>*(numeroSerie/<span class="pl-c1">4</span>) );
      limites.<span class="pl-c1">push_back</span>( numeroSerie );
  
      <span class="pl-c">// Creamos a hilos</span>
      thread hilos[<span class="pl-c1">4</span>];
  
      <span class="pl-c">// Inicializamos nuestros hilos</span>
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">4</span>; i++)
          hilos[i] = <span class="pl-c1">thread</span>( calcularIntervalo, i );
  
      <span class="pl-c">// Esperemos a que nuestros hilos terminen</span>
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">4</span>; i++)
          hilos[i].<span class="pl-c1">join</span>();
  
      <span class="pl-c">// Calculamos nuestra respuesta</span>
      <span class="pl-k">double</span> answer = <span class="pl-c1">0</span>;
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">4</span>; i++)
          answer += valorCal[i];
      answer *= <span class="pl-c1">4</span>;
      <span class="pl-c1">printf</span>( <span class="pl-s"><span class="pl-pds">"</span>EL valor de pi es:<span class="pl-cce">\t</span><span class="pl-c1">%.20f</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, answer );
      <span class="pl-k">return</span> <span class="pl-c1">0</span>;
  }</pre>
              </div>
  
              <p>Compilar: <strong>g++ pi.cpp -o pi -std=c++11 -pthread</strong></p>
  
              <p>Ejecutar: <strong>./pi</strong></p>
  
              <blockquote>
                <p>EL valor de pi es: 3.14159265258921038821</p>
              </blockquote>
  
              <ul>
                <li>Ejemplo en <strong>Java</strong>:</li>
              </ul>
              <p>Un grupo de personas trata de ir de una isla(Oahu) a la otra(Molokai) con un solo bote.</p>
              <p><img src="https://s1-ssl.dmcdn.net/hjNxe/x240-XWg.jpg" alt=""></p>
  
              <p>Reglas:</p>
              <ul>
                <li>Cada persona es un hilo.</li>
                <li>La persona puede ser un adulto o un niño.</li>
                <li>Pueden ir dos niños en el bote o solo un adulto.</li>
                <li>El bote necesita como mínimo un piloto./li>
                <li>las personas solo se pueden comunicar con los que estén en la misma isla.</li>
                <li>Siempre hay mínimo dos niños.</li>
              </ul>
  
              <p>El principal objetivo del ejemplo es mostrar la sincronización de los hilos, la solución al problema
                consiste en llevar dos niños
                a Molokai, hacer que uno se devuelva con el bote, subir un adulto en oahu, cuando este llegue a Molokai se
                devolverá el otro niño
                que estaba ahí, y en Oahu se volverán a subir dos niños, este proceso se repetirá hasta que todas las
                personas estén en Oahu,
                hay que tener en cuenta que no hay algo como unidad principal que controle cuando pasará cada persona,
                cada hilo deberá saber cuando
                ejecutar sus instrucciones dependiendo de la sincronización con los otros</p>
              <pre class="prettyprint">
  
  import java.util.concurrent.Semaphore;
  
  //extiende de thread y sobreescribe run sin nada
  public class Persona extends Thread{
  
    int Tamano;
    String ubicacion;
    static String boatUbication="Oahu";
    public static String getBoatUbication() {
      return boatUbication;
    }
  
    public static void setBoatUbication(String boatUbication) {
      Persona.boatUbication = boatUbication;
    }
  
    public Persona(int tamano, String ubicacion) {
      super();
      this.Tamano = tamano;
      this.ubicacion = ubicacion;
    }
  
    @Override
      public void run() {
  
    }
  
  
  
  }
  
  
  
  import java.util.logging.Level;
  import java.util.logging.Logger;
  
  //extiende de persona
  public class Adult extends Persona {
    public Adult() {
      super(2, "Oahu");
    }
    //sobreescribe run
    @Override
      public void run() {
      //mientras no hayan pasado todas las personas
      while(Boat.ContMolokai < Boat.ContTotalPersonas){
       try {
         //semaforo encargado de que un niño y adulto no luchen por el bote
         Boat.classExclus.acquire();
               if (this.ubicacion.equals("Oahu") && boatUbication.equals(this.ubicacion) && Boat.ContChildBack%2!=0 && Boat.ContAdultOahu != 0){
                 //si ve que puede pasar lo hace, adquiere las dos posiciones del bote
                 Boat.available.acquire();
                 Boat.available.acquire();
                 Boat.bg.AdultRowToMolokai();
                 this.ubicacion="Molokai";
                 boatUbication="Molokai";
                 Boat.ContMolokai++;
                  Boat.ContOahu--;
                  Boat.ContAdultOahu--;
                  //al llegar libera las dos posiciones del bote
                 Boat.available.release();
                 Boat.available.release();
               }
  
               Boat.classExclus.release();
           } catch (InterruptedException ex) {
               Logger.getLogger(Child.class.getName()).log(Level.SEVERE, null, ex);
           }
    }
    }
  }
  
  
  import java.util.concurrent.Semaphore;
  import java.util.logging.Level;
  import java.util.logging.Logger;
  
  //parecida a Adult
  public class Child extends Persona {
    public Child() {
      super(1, "Oahu");
    }
    @Override
      public void run() {
      while(Boat.ContMolokai < Boat.ContTotalPersonas ){
       try {
         Boat.classExclus.acquire();
               if (this.ubicacion.equals("Oahu") && boatUbication.equals(this.ubicacion) && (Boat.ContChildBack%2==0 || Boat.ContAdultOahu == 0) ){
                 //a diferencia del adulto el niño solo adquiere una posicion del bote
                 Boat.available.acquire();
                 Boat.UbicacionDispon--;
                 if (Boat.UbicacionDispon==1) Boat.bg.ChildRowToMolokai();
                 this.ubicacion="Molokai";
                 Boat.ContMolokai++;
                 Boat.ContOahu--;
                 if(Boat.UbicacionDispon==0){
                   Boat.bg.ChildRideToMolokai();
                   boatUbication="Molokai";
                   Boat.UbicacionDispon=2;
                 }
                 Boat.available.release();
               }
               //parte de la seccion critica encargada de que el niño regrese desde Molokai a Oahu
                 if (this.ubicacion.equals("Molokai") && boatUbication.equals(this.ubicacion) && (Boat.ContMolokai < Boat.ContTotalPersonas ) ){
                   //para evitar que se regresen dos niños el niño adquiere las dos posiciones
                   //del bote
                   Boat.available.acquire();
                   Boat.available.acquire();
                   Boat.bg.ChildRowToOahu();
                     this.ubicacion="Oahu";
                     boatUbication="Oahu";
                     Boat.ContMolokai--;
                     Boat.ContOahu++;
                     Boat.ContChildBack++;
                     //llega y libera las dos posiciones
                     Boat.available.release();
                     Boat.available.release();
                 }
  
                 Boat.classExclus.release();
           } catch (InterruptedException ex) {
               Logger.getLogger(Child.class.getName()).log(Level.SEVERE, null, ex);
           }
  
      }
    }
  
  }
  
  
  
  import java.util.Scanner;
  import java.util.concurrent.Semaphore;
  import java.util.LinkedList;
  
  public class Boat {
    //se instancian los dos semaforos
    public static Semaphore available = new Semaphore(2, true);
    public static Semaphore classExclus = new Semaphore(1, true);
    static Scanner sc = new Scanner(System.in);
    //contadores para la comunicacion
    static int childrenTot=0;
    static int adultTot=0;
    static int ContChilds=0;
    static int ContAdults=0;
    static int ContTotalPersonas=0;
    static int ContOahu=0;
    static int ContMolokai=0;
    static int ContAdultOahu=0;
    static int UbicacionDispon=2;
    static int ContChildBack=0;
  
    //arreglo de personas
    static LinkedList<Child> ChildList = new LinkedList<Child>();
    static LinkedList<Adult> AdultList = new LinkedList<Adult>();
    static BoatGrader bg= new BoatGrader();
  
    //se crean los hilos
    static public void begin(){
      for(Child element : ChildList){
        element.start();
  
  
      }
      for(Adult element : AdultList){
        element.start();
  
      }
      //al terminar los hilos hacen join con el hilo principal
      for(Child element : ChildList){
        try {
          element.join();
        } catch (InterruptedException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
      }
      for(Adult element : AdultList){
        try {
          element.join();
        } catch (InterruptedException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
      }
  
  
  
    }
  
    public static void main(String args[]) {
      //entradas del programa
      while (childrenTot< 2){
        System.out.println("Introduzca el numero de niños (mayor a 1): ");
        childrenTot=sc.nextInt();
      }
      System.out.println("Introduzca el numero de adultos: ");
      adultTot=sc.nextInt();
        for (int i=0;i< childrenTot;i++){
          ChildList.add(new Child());
          ContChilds++;
        }
        for (int i=0;i< adultTot;i++){
          AdultList.add(new Adult());
          ContAdults++;
        }
        ContTotalPersonas=ContChilds+ContAdults;
        ContAdultOahu=ContAdults;
      ContOahu=ContTotalPersonas;
  
        Boat.begin();
        System.out.println("llegaron "+ContMolokai+" personas");
    }
  }
  </pre>
              <p>ejecución:</p>
              <pre class="prettyprint">
    Introduzca el numero de niños (mayor a 1):
    3
    Introduzca el numero de adultos:
    5
    **Child rowing to Molokai.
    **Child arrived on Molokai as a passenger.
    **Child rowing to Oahu.
    **Adult rowing to Molokai.
    **Child rowing to Oahu.
    **Child rowing to Molokai.
    **Child arrived on Molokai as a passenger.
    **Child rowing to Oahu.
    **Adult rowing to Molokai.
    **Child rowing to Oahu.
    **Child rowing to Molokai.
    **Child arrived on Molokai as a passenger.
    **Child rowing to Oahu.
    **Adult rowing to Molokai.
    **Child rowing to Oahu.
    **Child rowing to Molokai.
    **Child arrived on Molokai as a passenger.
    **Child rowing to Oahu.
    **Adult rowing to Molokai.
    **Child rowing to Oahu.
    **Child rowing to Molokai.
    **Child arrived on Molokai as a passenger.
    **Child rowing to Oahu.
    **Adult rowing to Molokai.
    **Child rowing to Oahu.
    **Child rowing to Molokai.
    **Child arrived on Molokai as a passenger.
    **Child rowing to Oahu.
    **Child rowing to Molokai.
    **Child arrived on Molokai as a passenger.
    llegaron 8 personas
  
  
  </pre>
              <ul>
                <li>Ejemplo en <strong>Go</strong>:</li>
              </ul>
              <pre class="prettyprint">
    package main
    import(
      "fmt"
      "time"
    )
    func main() {
        fmt.Println("iniciando")
        go printForward()
        go printBackwards()
      time.Sleep(time.Second * 5)
        fmt.Println("terminando")
    }
    func printForward() {
        for i := 0; i < 10; i++ {
            fmt.Println(i)
            time.Sleep(time.Millisecond)
        }
    }
    func printBackwards() {
        for i := 10; i <= 20; i++ {
            fmt.Println(i)
            time.Sleep(time.Millisecond)
        }
    }
  </pre>
              <p>En Go tenemos rutinas que tienen su propio stack, aunque estos no son hilos como tal, pero si se pueden
                aprovechar de esta forma</p>
              <pre class="prettyprint">
  package main
  import(
    "fmt"
    "time"
  )
  func main() {
      c := make(chan string)
      go echo(c)
      c < - "Hola"
      mensaje := < - c
      fmt.Println(mensaje)
  }
  
  func echo(c chan string) {
      msg := < - c
      time.Sleep(time.Second * 1)
      c < - fmt.Sprintf("Mensaje recibido: %s", msg)
  }
  
  salida= Mensaje recibido:Hola
  </pre>
  
              <p>En Go tenemos el Select es como un switch, pero que espera mensajes en canales.
                Su finalidad es comunicar, no comparar valores. </p>
              <pre class="prettyprint">
  package main
  import(
    "fmt"
    "time"
  )
  func main() {
      process1 := processExpensiveTransaction()
      process2 := processExpensiveTransaction()
      for i := 0; i < 2; i++ {
          select {
              case msg1 := <- process1:
                  fmt.Println("Proceso 1 termino con status ", msg1)
              case msg2 := <- process2:
                  fmt.Println("Proceso 2 termino con status ", msg2)
          }
      }
  }
  
  func processExpensiveTransaction() chan string {
      c := make(chan string)
      go func() {
          time.Sleep(time.Duration(rand.Intn(6)) * time.Second)
          c <- "ok"
      } ()
      return c
  }
  </pre>
              <ul>
                <li>Otro Ejemplo en <strong>Go</strong>:</li>
              </ul>
              <p>
                En este ejemplo vamos a optimizar una aplicación que realiza peticiones http, haciendo uso de
                concurrencia,
                el siguiente código es la aplicación implementada de manera secuencial:
              </p>
              <pre class="prettyprint">
  package main
  import (
    "fmt"
    "log"
    "net/http"
    "os"
  )
  func sendRequest(url string){
    res, err := http.Get(url)
    if err != nil{
      panic(err)
    }
    fmt.Printf("Estado: %d URL: %s\n", res.StatusCode,url)
  }
  
  func main() {
    if len(os.Args) < 2 {
      log.Fatalln("Uso: go run main.go url1 url2 .. urln")
    }
  
    for _, url := range os.Args[1:] {
      sendRequest("https://" + url)
    }
  }
  </pre>
              <p>
                Para hacer uso del programa, usamos el siguiente comando:
              <pre class="prettyprint">
      go run main.go url1 url2 .. urln
    </pre>
              Donde url1 a urln se reemplazan por urls a las cuales queremos hacer la petición Get.
              Los resultados de esto deberían ser los siguientes, en el caso de haber usado las urls de google, youtube y
              facebook:
              </p>
              <pre class="prettyprint">
  Estado: 200 URL: https://facebook.com
  Estado: 200 URL: https://youtube.com
  Estado: 200 URL: https://google.com
  </pre>
              <p>
                Para medir el tiempo de ejecución se debe usar el siguiente comando:
              </p>
              <p>
                Para Windows:
              <pre class="prettyprint">
      Measure-Command {go run main.go url1 url2 .. urln}
      </pre>
              Para Linux:
              <pre class="prettyprint">
      time go run main.go url1 url2 .. urln
      </pre>
              Este tiempo de ejecución es importante para comparar el antes y el después de usar concurrencia. Haciendo
              uso del comando de Windows, obtuvimos como resultado:
              </p>
              <pre class="prettyprint">
  Days              : 0
  Hours             : 0
  Minutes           : 0
  Seconds           : 1
  Milliseconds      : 970
  Ticks             : 19702343
  TotalDays         : 2,28036377314815E-05
  TotalHours        : 0,000547287305555556
  TotalMinutes      : 0,0328372383333333
  TotalSeconds      : 1,9702343
  TotalMilliseconds : 1970,2343
  </pre>
              <p>
                Actualmente nuestra aplicación funciona de manera síncrona, lo cual ralentiza su procesamiento,
                debido a que tiene que esperar que cada petición termine para poder realizar la siguiente.
                Ahora vamos a modificar este programa inicial para usar concurrencia y optimizar nuestra aplicación:
              </p>
              <pre class="prettyprint">
    package main
    import (
      "fmt"
      "log"
      "net/http"
      "os"
    )
    func sendRequest(url string){
      res, err := http.Get(url)
      if err != nil{
        panic(err)
      }
      fmt.Printf("Estado: %d URL: %s\n", res.StatusCode,url)
    }
    
    func main() {
      if len(os.Args) < 2 {
        log.Fatalln("Uso: go run main.go url1 url2 .. urln")
      }
    
      for _, url := range os.Args[1:] {
        go sendRequest("https://" + url)
      }
    }
  </pre>
              <p>
                Con solo agregar la palabra go, hacemos que cada consulta se ejecute en goroutines separadas
                y si ejecutamos el comando de Benchmark anteriormente mencionado vamos a observar que
                el tiempo de ejecucion es mucho menor:
              </p>
              <pre class="prettyprint">
  Days              : 0
  Hours             : 0
  Minutes           : 0
  Seconds           : 0
  Milliseconds      : 832
  Ticks             : 8328442
  TotalDays         : 9,63940046296296E-06
  TotalHours        : 0,000231345611111111
  TotalMinutes      : 0,0138807366666667
  TotalSeconds      : 0,8328442
  TotalMilliseconds : 832,8442
  </pre>
              <p>
                Pero nos vamos a encontrar con un problema: no se imprimen los resultados de las goroutines
                en consola.
                Para corregir esto vamos a hacer uso de WaitGroup, el cual ayuda a contabilizar las rutinas que se tienen
                activas:
              </p>
              <pre class="prettyprint">
    package main
    import (
      "fmt"
      "log"
      "net/http"
      "os"
    )
  
    var wg sync.WaitGroup
  
    func sendRequest(url string){
      defer wg.Done() //Decrementa el contador de goroutines 
      res, err := http.Get(url)
      if err != nil{
        panic(err)
      }
      fmt.Printf("Estado: %d URL: %s\n", res.StatusCode,url)
    }
    
    func main() {
      if len(os.Args) < 2 {
        log.Fatalln("Uso: go run main.go url1 url2 .. urln")
      }
    
      for _, url := range os.Args[1:] {
        go sendRequest("https://" + url)
        wg.Add(1) //Incrementa el contador de goroutines 
      }
      wg.Wait() //Indica que toca esperar a que todas las goroutines terminen
    }
  </pre>
              <p>
                Si ejecutamos de nuevo nuestro programa, vamos a ver que los resultados ahora si se muestran en consola.
              </p>
              <pre class="prettyprint">
      Estado: 200 URL: https://facebook.com
      Estado: 200 URL: https://youtube.com
      Estado: 200 URL: https://google.com
    </pre>
              <p>
                Es posible que las goroutines se mezclen en consola, debido a que pueden terminar al mismo tiempo. Dando
                como resultado:
              </p>
              <pre class="prettyprint">
      Estado: 200 URL: Estado: 200 URL: https://youtube.comhttps://facebook.com
      Estado: 200 URL: https://google.com
    </pre>
              <p>
                Para evitar que esto ocurra vamos a hacer uso de Mutex, el cual ayuda a sincronizar el acceso a recursos
                compartidos, como es el caso de la consola.
                Para hacer uso de Mutex, hacemos lo siguiente:
              </p>
              <pre class="prettyprint">
      package main
      import (
        "fmt"
        "log"
        "net/http"
        "os"
      )
    
      var wg sync.WaitGroup
      var mut sync.Mutex
    
      func sendRequest(url string){
        defer wg.Done() //Decrementa el contador de goroutines
        res, err := http.Get(url)
        if err != nil{
          panic(err)
        }
        mut.Lock()  //Bloquea el recurso inferior para que solo esta gorutine 
                    //pueda hacer uso de este
        defer mut.Unlock() //Desbloquea el recursos despues de haber terminado de usarlo
        fmt.Printf("Estado: %d URL: %s\n", res.StatusCode,url)
      }
      
      func main() {
        if len(os.Args) < 2 {
          log.Fatalln("Uso: go run main.go url1 url2 .. urln")
        }
      
        for _, url := range os.Args[1:] {
          go sendRequest("https://" + url)
          wg.Add(1) //Incrementa el contador de goroutines
        }
        wg.Wait() //Indica que toca esperar a que todas las goroutines terminen
      }
    </pre>
              <ul>
                <li>Ejemplo de concurrecia en <strong>Erlang</strong>:</li>
              </ul>
              <p>
                La función spawn en Erlang nos permiete crear un proceso en paralelo.
              </p>
              <pre class="prettyprint">
    -module(helloworld).
    -export([start/0]).
    start() ->
      Pid = spawn(fun() -> server("Hello") end),
  
    server(Message) ->
      io:fwrite("~p",[Message]).
  </pre>
              <p>
                La salida es la siguiente:
              </p>
              <blockquote>
                "Hello"
              </blockquote>
  
              <p>
                El operador ! nos permite enviar mensajes a los procesos.
              </p>
              <pre class="prettyprint">
    -module(helloworld).
    -export([start/0]).
    start() ->
      Pid = spawn(fun() -> server("Hello") end),
      Pid ! {hello}.
  
    server(Message) ->
      io:fwrite("~p",[Message]).
  </pre>
              <p>
                La salida es la siguiente:
              </p>
              <blockquote>
                "Hello"
              </blockquote>
  
  
              <p>
                receive permite recibir mensajes que son enviados a los procesos.
              </p>
              <pre class="prettyprint">
    -module(helloworld).
    -export([loop/0,start/0]).
  
    loop() ->
       receive
          {rectangle, Width, Ht} ->
             io:fwrite("Area of rectangle is ~p~n" ,[Width * Ht]),
             loop();
          {circle, R} ->
          io:fwrite("Area of circle is ~p~n" , [3.14159 * R * R]),
          loop();
       Other ->
          io:fwrite("Unknown"),
          loop()
       end.
  
    start() ->
       Pid = spawn(fun() -> loop() end),
       Pid ! {rectangle, 6, 10},
       Pid ! {circle, 6},
       Pid ! {square, 4, 4}.
  </pre>
              <p>
                La salida es la siguiente:
              </p>
              <blockquote>
                Area of rectangle is 60<br>
                Area of circle is 113.09723999999999<br>
                Unknown<br>
              </blockquote>
  
              <ul>
                <li>Ejemplo de concurrecia en <strong>Rust</strong>:</li>
              </ul>
              <p>
                Rust facilita la programación concurrente con las comprobaciones que se hacen en tiempo de compilación y
                con la gestión de memoria que realiza.
              </p>
              <p>
                Hilos: creamos hilos con el comando thread::spawn, que recibe un closure y se lanza justo al definirlo.
              </p>
              <pre class="prettyprint">
    use std::thread;
  
    fn main() {
        let child = thread::spawn(|| {
            println!("Hello from a thread!");
        });
        let _ = child.join();
    }
  </pre>
              <p>
                La salida es la siguiente:
              </p>
              <blockquote>
                Hello from a thread!
              </blockquote>
  
              <p>
                Para esperar a que un hilo termine se puede utilizar el método join.
              </p>
              <p>
                Podemos lanzar varios hilos dentro de un bucle
              </p>
              <!--<p>
    Se crea un Vec donde se meten todos los hilos para luego poder hacer un join y esperar a que todos terminen. Dentro del hilo se imprime por pantalla el índice de la iteración.
  </p>-->
              <p>Aquí, en cada vuelta del bucle, iniciaremos un hilo con un iterador asociado. El primer hilo se inicia
                con el número 0, el segundo con el número 1 y así sucesivamente.
                Podemos ver en el resultado lo que se dijo antes: los subprocesos se lanzaron en un orden específico y,
                sin embargo, al mostrar los resultados, vemos que está completamente desordenado: de hecho, la velocidad
                de la ejecución de cada uno de los hilos variará.
  
                Si reiniciamos este programa, su salida y la visualización de los números serán diferentes; es imposible
                de predecir el orden de los números que aparecerán. Pero, si utilizamos el sistema de bloqueo y
                desbloqueo, para que cada hilo espere hasta que el anterior termine, el orden será perfecto.</p>
              <pre class="prettyprint">
    use std::thread;
  
    fn main() {
      let mut childs = vec![];
  
      for i in 0..10 {
          let child = thread::spawn(move || {
              println!("Hello from a thread! {}", i);
          });
          childs.push(child);
      }
  
      for c in childs {
          let _ = c.join();
      }
    }
  </pre>
              <p>
                La salida es la siguiente:
              </p>
              <blockquote>
                Hello from a thread! 1 <br>
                Hello from a thread! 0 <br>
                Hello from a thread! 5 <br>
                Hello from a thread! 3 <br>
                Hello from a thread! 7 <br>
                Hello from a thread! 4 <br>
                Hello from a thread! 8 <br>
                Hello from a thread! 6 <br>
                Hello from a thread! 2 <br>
                Hello from a thread! 9 <br>
  
              </blockquote>
  
  
              <p>
                Mutex y Arc: Para compartir una referencia a memoria entre hilos se usa Arc y Mutex en combinación.
                Arc es un contador de referencias que se puede compartir entre hilos.
                Mutex implementa el bloqueo asociado a la variable en concreto.
  
              </p>
              <pre class="prettyprint">
    use std::thread;
    use std::sync::{Arc, Mutex};
  
    fn main() {
        let mut childs = vec![];
        let shared = Arc::new(Mutex::new(String::from("")));
  
        for i in 0..10 {
            let s = shared.clone();
            let child = thread::spawn(move || {
                println!("In thread {}", i);
  
                let out = String::from("Thread ") + &i.to_string() + "\n";
                s.lock().unwrap().push_str(&out);
            });
            childs.push(child);
        }
  
        for c in childs {
            let _ = c.join();
        }
  
        println!("\nOutput:\n{}", *(shared.lock().unwrap()));
    }
  
  </pre>
              <p>
                La salida es la siguiente:
              </p>
              <blockquote>
                In thread 0 <br>
                In thread 3 <br>
                In thread 5 <br>
                In thread 4 <br>
                In thread 2 <br>
                In thread 6 <br>
                In thread 7 <br>
                In thread 8 <br>
                In thread 1 <br>
                In thread 9 <br>
                <br>
                Output: <br>
                Thread 0 <br>
                Thread 3 <br>
                Thread 5 <br>
                Thread 4 <br>
                Thread 2 <br>
                Thread 6 <br>
                Thread 7 <br>
                Thread 8 <br>
                Thread 1 <br>
                Thread 9 <br>
              </blockquote>
  
              <p>
                En este ejemplo se define la cadena dentro de un Mutex y este dentro de un Arc, así se comparte la memoria
                entre hilos.
                <br>
                channel crea un transmisor, tx, y un receptor, rx, en cada hilo, clona el transmisor y escribe en este la
                salida. En el send se puede enviar cualquier tipo de dato según se cree el channel, no se pueden enviar
                diferentes tipos de datos por el mismo canal.
  
              </p>
              <pre class="prettyprint">
    use std::thread;
    use std::sync::mpsc;
  
    fn main() {
        let (tx, rx) = mpsc::channel();
        let mut childs = vec![];
  
        for i in 0..10 {
            let tx = tx.clone();
            let child = thread::spawn(move || {
                println!("In thread {}", i);
  
                let out = String::from("Thread ") + &i.to_string();
                tx.send(out).unwrap();
            });
            childs.push(child);
        }
  
        for c in childs {
            let _ = c.join();
        }
  
        println!("\nOutput:");
        loop {
            match rx.try_recv() {
                Ok(x) => println!("{}", x),
                Err(_) => break
            }
        }
    }
  
  </pre>
              <p>
                La salida es la siguiente:
              </p>
              <blockquote>
                In thread 0 <br>
                In thread 2 <br>
                In thread 1 <br>
                In thread 4 <br>
                In thread 5 <br>
                In thread 6 <br>
                In thread 3 <br>
                In thread 8 <br>
                In thread 7 <br>
                In thread 9 <br>
                <br>
                Output: <br>
                Thread 0 <br>
                Thread 2 <br>
                Thread 1 <br>
                Thread 4 <br>
                Thread 5 <br>
                Thread 6 <br>
                Thread 8 <br>
                Thread 7 <br>
                Thread 9 <br>
                Thread 3 <br>
              </blockquote>
  
              <ul>
                <li>Ejemplo de concurrencia en <strong>Crystal</strong>:</li>
              </ul>
              <p>
                Crystal usa hilos llamados fibras para lograr concurrencia. Las fibras se comunican entre sí mediante
                canales, como en Go o Clojure, sin tener que recurrir a la memoria compartida o bloqueos.
                <br>
                Cuando se inicia un programa, se activa la fibra principal que ejecutará su código de nivel superior.
                Allí, uno puede engendrar (spawn) más fibras.
                Los componentes de un programa son:
              <ul>
                <li>Runtime Scheduler, a cargo de ejecutar todas las fibras cuando sea el momento adecuado. </li>
                <li>El bucle de eventos, que es solo otra fibra, está a cargo de tareas asíncronas, como por ejemplo
                  archivos, sockets, pipes, señales y temporizadores.</li>
                <li>Canales, para comunicar datos entre fibras. Runtime Scheduler coordinará fibras y canales para su
                  comunicación.</li>
                <li>Garbage collector: para limpiar la memoria que "ya no se usa".</li>
              </ul>
              Fibras: Para generar una fibra se usa el comando spawn
              </p>
  
              <pre class="prettyprint">
    spawn do
      loop do
        puts "Hello!"
      end
    end
  
    sleep 1.second
  </pre>
              <p>
                Este programa imprimirá "¡Hello!" por un segundo y luego saldrá. Esto se debe a que la llamada de espera
                programará la fibra principal que se ejecutará en un segundo y luego ejecutará otra fibra "lista para
                ejecutarse", que en este caso es la de arriba.
                <br><br>
                Otra manera seria:
              </p>
  
              <pre class="prettyprint">
    spawn do
      loop do
        puts "Hello!"
      end
    end
  
    Fiber.yield
  </pre>
  
              <p>
                Fiber.yield le dirá al scheduler que ejecute la otra fibra. Esto imprimirá "Hello" hasta los bloques de
                salida estándar y luego la ejecución continuará con la fibra principal y el programa saldrá.
              </p>
  
              <p>
                Creando(spawn) una llamada:
                <br><br>
                El programa imprime los números del 0 al 9. Se crea un Proc y se invoca pasando I, por lo que el valor se
                copia y la fibra engendrada recibe una copia.
              </p>
  
              <pre class="prettyprint">
    i = 0
    while i < 10
      proc = ->(x : Int32) do
        spawn do
          puts(x)
        end
      end
      proc.call(i)
      i += 1
    end
  
    Fiber.yield
  </pre>
  
              <p>
                La salida es la siguiente:
              </p>
  
              <blockquote>
                0 <br>
                1 <br>
                2 <br>
                3 <br>
                4 <br>
                5 <br>
                6 <br>
                7 <br>
                8 <br>
                9 <br>
              </blockquote>
  
              <p>
                Canales:
                <br>
                Cuando el programa ejecuta una recepción, esa fibra se bloquea y la ejecución continúa con la otra fibra.
                Cuando se ejecuta un envió, la ejecución continúa con la fibra que estaba esperando en ese canal.
              </p>
  
              <pre class="prettyprint">
    channel = Channel(Int32).new
  
    spawn do
      puts "Before first send"
      channel.send(1)
      puts "Before second send"
      channel.send(2)
    end
  
    puts "Before first receive"
    value = channel.receive
    puts value # => 1
  
    puts "Before second receive"
    value = channel.receive
    puts value # => 2
  </pre>
              <p>
                La salida es la siguiente:
              </p>
              <blockquote>
                Before first receive <br>
                Before first send <br>
                1 <br>
                Before second receive <br>
                Before second send <br>
                2 <br>
  
              </blockquote>
  
              <ul>
                <li>Ejemplo en <strong>C</strong> con el juego de pacman:<br />
                  Aquí, el programa debe poder recibir la entrada teclado del usuario. Pero también, al mismo tiempo,
                  tienes que:
                  <br />
                  - Calcula los movimientos de los enemigos gracias a la inteligencia artificial.<br />
                  - Ver los diferentes desplazamientos.<br />
                  - Actualizar el mapa<br />
                </li>
              </ul>
  
              <div class="highlight highlight-source-python">
                <pre>
  <span class="pl-k">int</span> <span class="pl-en">main_loop</span>(<span class="pl-smi">IGame *Game, IGui *curse</span>):
    {
      <span class="pl-k">board</span> game;
      <span class="pl-k">t_orientation</span> dir;
      <span class="pl-k">int</span> k = 0;
  
      <span class="pl-s">while</span> (k == 0)
      {
        dir = curse-><span class="pl-c1">get_touch</span>();
        <span class="pl-s">if</span> (dir > 4)
          <span class="pl-c1">return</span> (dir);
        k = Game-><span class="pl-c1">check_move</span>(dir);
        game = Game-><span class="pl-c1">get_board</span>();
        <span class="pl-s">if</span> (curse-><span class="pl-c1">display</span>(game) == -1)
          <span class="pl-c1">return</span> (0);
      }
      <span class="pl-c1">delete</span> curse;
      <span class="pl-c1">delete</span> Game;
      <span class="pl-c1">return</span> (0);
    }
  </pre>
              </div>
  
              <p>Si observamos el código que se muestra, la función get_touch iniciará un hilo que se ocupará de recuperar
                la entrada del teclado pero no bloqueará el resto del programa: no esperará a recuperar una tecla para
                continuar.</p>
  
              <img src="images/Pacman.gif"><br /><br /><br />
  
  
     
          </div>
        </div>


      </section><!-- #about -->
      <section id="ejemploComparativo" style="margin-top: 50px;">
        <div class="container">
          <div class="text_cell_render border-box-sizing rendered_html">
            <h2 class="title"><strong>Ejemplo Comparativo</strong></h2>
            
            <h2>Suma concurrente</h2>
            <p>
                Dado un arreglo de números, queremos sumar todos sus elementos. Utilizaremos programación concurrente para dividir el trabajo entre varios workers y sumar los resultados parciales.
                Esta solución será implementada en tres lenguajes diferentes: Go, Elixir y Rust. Cada lenguaje tiene sus propias características y formas de manejar la concurrencia.
                A continuación, se presenta el código para cada uno de estos lenguajes seguido de una tabla comparativa que detalla las diferentes secciones del código y cómo se implementan en cada lenguaje.
            </p>
            <h3>Go</h3>
            <pre class="prettyprint"><code>
    package main

    import (
    "fmt"
    "sync"
    )

    func worker(arr []int, wg *sync.WaitGroup, resultChan chan int) {
    defer wg.Done()
    sum := 0
    for _, num := range arr {
      sum += num
    }
    resultChan <- sum
    }

    func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    numWorkers := 2
    chunkSize := len(arr) / numWorkers
    resultChan := make(chan int, numWorkers)
    var wg sync.WaitGroup

    for i := 0; i < numWorkers; i++ {
      start := i * chunkSize
      end := start + chunkSize
      if i == numWorkers-1 {
          end = len(arr)
      }
      wg.Add(1)
      go worker(arr[start:end], &wg, resultChan)
    }

    wg.Wait()
    close(resultChan)

    totalSum := 0
    for sum := range resultChan {
      totalSum += sum
    }

    fmt.Printf("Total Sum: %d\n", totalSum)
    }
</code> </pre>

            <h3>Elixir</h3>
            <pre class="prettyprint">

    defmodule ConcurrentSum do
    def worker(pid, list) do
    sum = Enum.sum(list)
    send(pid, {self(), sum})
    end

    def start(list) do
    num_workers = 2
    chunk_size = div(length(list), num_workers)
    pids = for i <- 1..num_workers do
    start = (i - 1) * chunk_size + 1
    finish = min(start + chunk_size - 1, length(list))
    spawn(ConcurrentSum, :worker, [self(), Enum.slice(list, start - 1, finish - start + 1)])
    end
    receive_results(pids, 0)
    end

    defp receive_results([], acc) do
    IO.puts("Total Sum: #{acc}")
    end

    defp receive_results(pids, acc) do
    receive do
    {_, sum} -> 
      receive_results(tl(pids), acc + sum)
    end
    end
    end

    ConcurrentSum.start([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
                </pre>

                <h3>Rust</h3>
                <pre class="prettyprint">

    use std::sync::mpsc;
    use std::thread;

    fn worker(arr: &[i32], tx: mpsc::Sender<i32>) {
    let sum: i32 = arr.iter().sum();
    tx.send(sum).expect("Could not send data!");
    }

    fn main() {
    let arr = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let num_workers = 2;
    let chunk_size = arr.len() / num_workers;

    let (tx, rx) = mpsc::channel();
    let mut handles = vec![];

    for i in 0..num_workers {
      let start = i * chunk_size;
      let end = if i == num_workers - 1 {
          arr.len()
      } else {
          start + chunk_size
      };
      let chunk = arr[start..end].to_vec();
      let tx = tx.clone();
      let handle = thread::spawn(move || {
          worker(&chunk, tx);
      });
      handles.push(handle);
    }

    for handle in handles {
      handle.join().expect("Thread couldn't join!");
    }

    let total_sum: i32 = rx.iter().take(num_workers).sum();
    println!("Total Sum: {}", total_sum);
    }
            </pre>

            <h2>Tabla Comparativa</h2>
    <table>
        <thead>
            <tr>
                <th class="narrow-col">Sección</th>
                <th>Go</th>
                <th>Elixir</th>
                <th>Rust</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>División del Trabajo</td>
                <td>
                    <ul>
                        <li>El arreglo se divide en partes iguales según el número de workers.</li>
                        <li>Cada parte del arreglo se procesa concurrentemente por una goroutine (goroutines son ligeras y se gestionan por el runtime de Go).</li>
                    </ul>
                    <pre class="prettyprint">
  for i := 0; i < numWorkers; i++ {
      start := i * chunkSize
      end := start + chunkSize
      if i == numWorkers-1 {
          end = len(arr)
      }
      wg.Add(1)
      go worker(arr[start:end], &wg, resultChan)
  }
                    </pre>
                </td>
                <td>
                    <ul>
                        <li>El arreglo se divide en partes iguales según el número de workers.</li>
                        <li>Cada parte del arreglo se procesa concurrentemente por un proceso ligero en Elixir.</li>
                    </ul>
                    <pre class="prettyprint">
  pids = for i <- 1..num_workers do
    start = (i - 1) * chunk_size + 1
    finish = min(start + chunk_size - 1, length(list))
    spawn(ConcurrentSum, :worker, [self(), Enum.slice(list, start - 1, finish - start + 1)])
  end
                    </pre>
                </td>
                <td>
                    <ul>
                        <li>El arreglo se divide en partes iguales según el número de workers.</li>
                        <li>Cada parte del arreglo se procesa concurrentemente por un hilo.</li>
                    </ul>
                    <pre class="prettyprint">
  for i in 0..num_workers {
      let start = i * chunk_size;
      let end = if i == num_workers - 1 { arr.len() } else { start + chunk_size };
      let chunk = arr[start..end].to_vec();
      let result = Arc::clone(&result);

      let handle = thread::spawn(move || {
          let sum: i32 = chunk.iter().sum();
          let mut total = result.lock().unwrap();
          *total += sum;
      });
      handles.push(handle);
  }
                    </pre>
                </td>
            </tr>
            <tr>
                <td>Sincronización</td>
                <td>
                    <ul>
                        <li>Se utiliza un sync.WaitGroup para esperar a que todas las goroutines terminen su trabajo.</li>
                        <li>Los resultados parciales se envían a través de un canal (resultChan).</li>
                    </ul>
                    <pre class="prettyprint">
  var wg sync.WaitGroup

  wg.Wait()
  close(resultChan)
                    </pre>
                </td>
                <td>
                    <ul>
                        <li>Los procesos workers envían las sumas parciales al proceso principal mediante mensajes.</li>
                    </ul>
                    <pre class="prettyprint">
  send(pid, {self(), sum})
                    </pre>
                </td>
                <td>
                    <ul>
                        <li>Usa Arc (Atomic Reference Counted) para compartir el resultado entre los hilos.</li>
                        <li>Usa Mutex para proteger el acceso concurrente al resultado compartido.</li>
                    </ul>
                    <pre class="prettyprint">
  let result = Arc::new(Mutex::new(0));
                    </pre>
                </td>
            </tr>
            <tr>
                <td>Recolección de Resultados</td>
                <td>
                    <ul>
                        <li>El canal resultChan se cierra cuando todos los workers han terminado.</li>
                        <li>Se suma cada resultado parcial recibido del canal para obtener la suma total.</li>
                    </ul>
                    <pre class="prettyprint">
  totalSum := 0
  for sum := range resultChan {
      totalSum += sum
  }

  fmt.Printf("Total Sum: %d\n", totalSum)
                    </pre>
                </td>
                <td>
                    <ul>
                        <li>El proceso principal recibe los resultados parciales de cada worker y los suma.</li>
                    </ul>
                    <pre class="prettyprint">
  receive do
    {_, sum} -> 
      receive_results(tl(pids), acc + sum)
  end
                    </pre>
                </td>
                <td>
                    <ul>
                        <li>Cada hilo añade su suma parcial al resultado total protegido por un Mutex.</li>
                    </ul>
                    <pre class="prettyprint">
  for handle in handles {
      handle.join().unwrap();
  }

  println!("Total Sum: {}", *result.lock().unwrap());
                    </pre>
                </td>
            </tr>
        </tbody>
    </table>
          </div>
        </div>
      </section>
      
      <!-- #about -->
    </main>


    <footer id="footer">
      <div class="container">
        <div class="credits">
          Creado por estudiantes del curso Lenguajes de Programación de la
          Universidad Nacional de Colombia.
        </div>
      </div>
    </footer>
    <!-- #footer -->

    <a href="#" class="back-to-top"><i class="fa fa-chevron-up"></i></a>

    <!-- JavaScript Libraries -->
    <script src="lib/jquery/jquery.min.js"></script>
    <script src="lib/jquery/jquery-migrate.min.js"></script>
    <script src="lib/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="lib/easing/easing.min.js"></script>
    <script src="lib/wow/wow.min.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD8HeI8o-c1NppZA-92oYlXakhDPYR7XMY"></script>

    <script src="lib/waypoints/waypoints.min.js"></script>
    <script src="lib/counterup/counterup.min.js"></script>
    <script src="lib/superfish/hoverIntent.js"></script>
    <script src="lib/superfish/superfish.min.js"></script>

    <!-- Contact Form JavaScript File -->
    <script src="contactform/contactform.js"></script>

    <!-- Template Main Javascript File -->
    <script src="js/main.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        prettyPrint();
      });
    </script>
    
  </body>
</html>
