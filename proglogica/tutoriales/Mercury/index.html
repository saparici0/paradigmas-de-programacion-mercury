<!DOCTYPE HTML>
<!--
	Strata by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Mercury</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="assets/css/main.css" />
		<!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->

	</head>
	<body id="top">

		<!-- Header -->
			<header id="header">
				<div class="inner">
					<a style="border-radius: 30%;" href="https://mercurylang.org/" target="blank" class="image avatar"><img src="images/mercury.png" alt="" /></a>
					<h1 style="font-size: 80px;"><strong>Mercury</strong>
				</div>
				<ul class="actions">
					<li><a href="https://mercurylang.org/information/doc-release/reference_manual.pdf" class="button" target="blank">Manual de referencia</a></li>
				</ul>
				<ul class="actions">
					<li><a href="https://mercurylang.org/information/doc-release/user_guide.pdf" class="button" target="blank">Guia del usuario</a></li>
				</ul>
			</header>

		<!-- Main -->
			<div id="main">

				<!-- One -->
					<section id="one">
						<header class="major">
							<h2>Introducción</h2>
						</header>
						<p>Mercury es un lenguaje de programación lógica / funcional que combina la claridad y la expresividad de la programación declarativa con funciones avanzadas de análisis estático y detección de errores. Como lenguaje lógico, está basado en el cálculo de predicados de primer orden y utiliza un sistema de inferencia automático para deducir conclusiones a partir de hechos y reglas declarados.

						</p>
						<p>Dentro de sus características, se destacan:
						</p>
						<ul style="list-style-type: circle; margin-left: 20px;">
 							<li>Basado en prolog (recomendamos el tutorial disponible <a href="http://ferestrepoca.github.io/paradigmas-de-programacion/proglogica/tutoriales/prolog-gh-pages/index.html" target="blank">aquí</a>)</li>
 							<li>Soporta modos</li>
 						 	<li>Tiene un fuerte sistema de determinismo</li>
 						 	<li>Tiene garbage collector</li>
 						 	<li>Es modularizado</li>
 						 	<li>Su compilador facilita el análisis estático y la optimización de código</li>
 						 	<li>Variedad de lenguajes de destino</li>
							<li>Compila a código de máquina</li>
							<li>Contiene un sistema de depuración avanzada</li>
							<li>Permite generar automáticamente documentación a partir de anotaciones dentro del código</li>
						</ul>

					</section>

				<!-- Two -->
					<section id="two">
						<header class="major">
							<h2>Instalación</h2>
						</header>
						<p>Unix <i style="color: black;">(recomendado): </i>
						</p>
						<ul style="list-style-type: decimal; margin-left: 20px;">
 							<li>Se requiere instalar GNU C (gcc) y GNU Make</li>
							 <div class="code-container">
								<pre>
								  <code>sudo apt update <br>sudo apt install build-essential
								  </code>
								</pre>
							  </div>
 							<li>Descargar la clave GPG del autor del software y autorizar al sistema operativo para descargar cualquier software publicado por el autor.</li>
							 <div class="code-container">
								<pre>
								  <code>sudo apt install wget ca-certificates <br>cd /tmp <br>wget https://paul.bone.id.au/paul.asc <br>sudo cp paul.asc /etc/apt/trusted.gpg.d/paulbone.asc
								  </code>
								</pre>
							  </div>
							<li>Se debe agregar el repositorio de software al sistema operativo. </li>
							  <div class="code-container">
								 <pre>
								   <code>sudo nano /etc/apt/sources.list <br># Dentro del archivo, agregar las siguientes líneas <br>deb http://dl.mercurylang.org/deb/ DISTRO main <br>deb-src http://dl.mercurylang.org/deb/ DISTRO main <br># Donde “DISTRO” es el nombre de versión del sistema operativo (sid, bookworm, bullseye, disco, focal, jammy)
								   </code>
								 </pre>
							   </div>
							<li>Instalar el conjunto de paquetes recomendado. </li>
							   <div class="code-container">
								  <pre>
									<code>sudo apt install mercury-recommended</code>
								  </pre>
								</div>
 						 	Para más información, haga click <a href="https://www.mercurylang.org/download/release.html" target="blank">aquí</a>
						</ul>
					</section>

				<!-- Three -->
					<section id="three">
						<header class="major">
							<h2>Compilación</h2>
						</header>
						<p>
							Inicialmente se crea un archivo hello.m (o cualquier otro nombre) dónde irá el código del programa. Para compilarlo y ejecutarlo en la consola basta con escribir:
						</p>

						<div class="code-container">
							<pre>
								<code>mmc hello.m<br>./hello</code>
							</pre>
						</div>

						<p>
							mmc hace referencia al compilador de Mercury. Y si queremos evitar la generación de archivos adicionales no necesarios, podemos simplemente escribir:<br>
						</p>

						<div class="code-container">
							<pre>
								<code>mmc --make hello.m<br>./hello</code>
							</pre>
						</div>
					</section>

					<section id="four">
						<header class="major">
							<h2>Tutorial</h2>
						</header>
						<p>
							Tutorial básico de programación lógica en Mercury, donde se abordan cuatro temas principales:
						</p>
						<ul style="list-style-type: circle; margin-left: 20px;">
 							<li>
 								Modos
 							</li>
 							<li>
 								Predicados
 							</li>
 						 	<li>
 						 		Determinismo
 						 	</li>
 						 	<li>
 						 		Tipos
 						 	</li>
						</ul>
						<ul class="actions">
							<li><a href="TutorialMercury.pdf" class="button" target="blank">Tutorial</a></li>
						</ul>
					</section>

					<section id="five">
						<header class="major">
							<h2>Ejemplos</h2>
						</header>
						<p>
							A continuación un conjunto de ejemplos progresivamente más complejos, cada uno con un link al ambiente en linea donde se puede ejecutar el código automáticamente:
						</p>
						<ul style="list-style-type: circle; margin-left: 20px;">
							<li><a href="https://glot.io/new/mercury" target="_blank" rel="noopener noreferrer">hello.m</a></li>
							<div class="code-container">
								<pre>
									<code>:- module hello.<br>:- interface.<br>:- import_module io.<br><br>:- pred main(io::di, io::uo) is det.<br><br>:- implementation.<br><br>main(!IO) :-<br>   io.write_string("Hello World!", !IO).<br></code>
								</pre>
							</div>
							<li><a href="https://glot.io/snippets/gx6e5r6rq5" target="_blank" rel="noopener noreferrer">addc.m</a></li>
							<br>
							<p>
								El siguiente es un ejemplo que demuestra la integración de Mercury con C, Java y C#. En este caso el código usa la función sumar implementada en C y la llama dentro del código de Mercury. Se usa el "pragma" foreign_proc para declarar la función.
							</p>
							<div class="code-container">
								<pre>
									<code>:- module addc.<br>:- interface.<br>:- import_module io.<br>:- pred main(io::di, io::uo) is det.<br>:- implementation.<br>:- import_module string, int.<br>:- pred add(int::in, int::in, int::out) is det.<br>:- pragma foreign_proc("C",<br>    add(A::in, B::in, Result::out),<br>    [will_not_call_mercury, promise_pure, thread_safe],<br>"<br>    int add(int a, int b) {<br>        return a + b;<br>    }<br>    Result = add(A,B);<br>").<br>main(!IO) :-<br>    io.read_line_as_string(ResultA, !IO),<br>    (<br>        ResultA = ok(LineA),<br>        StrippedA = string.strip(LineA),<br>        ( if string.to_int(StrippedA, A) then<br>            io.read_line_as_string(ResultB, !IO),<br>            (<br>                ResultB = ok(LineB),<br>                StrippedB = string.strip(LineB),<br>                ( if string.to_int(StrippedB, B) then<br>                    add(A, B, Sum),<br>                    io.write_string("The sum is: ", !IO),<br>                    io.write_int(Sum, !IO),<br>                    io.nl(!IO)<br>                else<br>                    B = 0,<br>                    add(A, B, Sum),<br>                    io.write_string("The sum is: ", !IO),<br>                    io.write_int(Sum, !IO),<br>                    io.nl(!IO)<br>                )<br>            ;<br>                ResultB = eof,<br>                io.write_string("Unexpected end of second <br>nput\n", !IO)<br>            ;<br>                ResultB = error(ErrorCode),<br>                io.write_string(io.error_message(<br>rrorCode) ++ "\n", !IO)<br>            )<br>        else<br>            A = 0,<br>            B = 0,<br>            add(A, B, Sum),<br>            io.write_string("The sum is: ", !IO),<br>            io.write_int(Sum, !IO),<br>            io.nl(!IO)<br>        )<br>    ;<br>        ResultA = eof,<br>        io.write_string("Unexpected end of first<br>input\n", !IO)<br>    ;<br>        ResultA = error(ErrorCode),<br>        io.write_string(io.error_message(ErrorCode) ++ <br>\n", !IO)<br>    ).<br></code>
								</pre>
							</div>
							<br>
							<li><a href="https://glot.io/snippets/gx6f5maqw7" target="_blank" rel="noopener noreferrer">puzzle.m</a></li>
							<br>
							<p>
								Para demostrar las funcionalidades de Mercury para tareas más complejas. Vamos a tratar de resolver el siguiente problema:<br><br>
								Hay una calle con tres casas vecinas que tienen cada una un color diferente. Son rojos, azules y verdes. En las diferentes casas viven personas de diferentes nacionalidades y todos tienen una mascota diferente. Aquí hay algunos datos más sobre ellos:<br>
								El inglés vive en la casa roja.<br>
								El jaguar es la mascota de la familia española.<br>
								Los japoneses viven a la derecha del cuidador de caracoles.<br>
								El cuidador de los caracoles vive a la izquierda de la casa azul.<br>
								¿Quién se queda con la cebra?<br>
							</p>
							<div class="code-container">
								<pre>
									<code>:- module puzzle.<br>:- interface.<br>:- import_module io.<br>:- pred main(io::di, io::uo) is det.<br>:- implementation.<br>:- import_module list, string, solutions.<br><br>% especificacion de los tipos de datos y los valores posibles<br>:- type origenes ---> ingles; japones; espanol.<br>:- type colores ---> rojo; azul; verde.<br>:- type mascotas ---> jaguar; caracol; cebra.<br>:- type casa<br>    --->    casa(<br>                origen :: origenes,<br>                color :: colores,<br>                mascota :: mascotas<br>            ).<br><br>% funcion para determinar que dos casas no sean iguales<br>:- pred distinct(casa::in, casa::in) is semidet.<br>distinct(casa(O1, C1, M1), casa(O2, C2, M2)) :-<br>    not (O1 = O2; C1 = C2; M1 = M2).<br><br>:- pred fila(list(casa)::out) is nondet.<br>fila([X, Y, Z]) :-<br>    casa(X), casa(Y), casa(Z),<br>    % los japoneses viven a la derecha del cuidador de caracoles<br>    X^mascota = caracol     <=> Y^origen = japones,<br>    Y^mascota = caracol     <=> Z^origen = japones,<br>    % el cuidador de los caracoles vive a la izquierda de la casa azul<br>    Z^color = azul          <=> Y^mascota = caracol,<br>    Y^color = azul          <=> X^mascota = caracol,<br>    % los japoneses viven a la derecha del cuidador de caracoles<br>    not X^origen = japones,<br>    % el cuidador de los caracoles vive a la izquierda de la casa azul<br>    not Z^mascota = caracol,<br>    distinct(X, Y), distinct(Y, Z), distinct(X, Z).<br><br>:- pred casa(casa::out) is nondet.<br>casa(casa(O, C, M)) :-<br>    % verificamos que los datos de la casa son validos<br>    origen(O), color(C), mascota(M),<br>    % el ingles vive en la casa roja<br>    O = ingles <=> C = rojo,<br>    % el jaguar es la mascota de la familia española<br>    O = espanol <=> M = jaguar,<br>    % los japoneses viven a la dereca del cuidador de caracoles<br>    not (O = japones, M = caracol),<br>    % el cuidador de caracoles vive a la izquierda de la casa azul<br>    not (M = caracol, C = azul).<br><br>main(!IO) :-<br>    solutions(fila, Soluciones),<br>    ( if Soluciones = [] then<br>        io.write_string("Sin solucion.\n", !IO)<br>    else<br>        foldl((pred(L::in, !.IO::di, !:IO::uo) is det :-<br>            io.print(L, !IO),<br>            io.nl(!IO)), Soluciones, !IO)<br>    ).<br><br>:- pred origen(origenes::out) is multi.<br>origen(ingles).<br>origen(japones).<br>origen(espanol).<br><br>:- pred color(colores).<br>:- mode color(out) is multi.<br>:- mode color(in) is det.<br>color(rojo).<br>color(azul).<br>color(verde).<br><br>:- pred mascota(mascotas::out) is multi.<br>mascota(jaguar).<br>mascota(caracol).<br>mascota(cebra).<br></code>
								</pre>
							</div>
							<br />
							<p>
								Ahora miremos con detalle los algoritmos y su ejecución en Mercury.
							</p>
							<br />
							<p>
								Este ejemplo implementa el algoritmo de ordenamiento por selección. Ordena una lista de
								enteros y muestra la lista ordenada en la consola.
							</p>
							<div class="code-container">
								<pre>
									<code>:- module selection_sort.<br />:- interface.<br />:- import_module io.<br /><br />:- pred main(io::di, io::uo) is det.<br /><br />:- implementation.<br />:- import_module list, int, string.<br /><br />% Predicado principal<br />main(!IO) :-<br /> % Lista de ejemplo<br /> List = [64, 25, 12, 22, 11],<br /><br /> % Ordenar la lista usando el algoritmo de ordenamiento por selección<br /> SelectionSortedList = selection_sort(List),<br /><br /> % Mostrar la lista ordenada<br /> io.write_string("Lista ordenada: ", !IO),<br /> io.write_list(SelectionSortedList, ", ", int_to_string, !IO),<br /> io.nl(!IO).<br /><br />% Función para convertir un entero a cadena<br />:- func int_to_string(int) = string.<br />int_to_string(Int) = string.from_int(Int).<br /><br />% Predicado de ordenamiento por selección<br />:- func selection_sort(list(int)) = list(int).<br />selection_sort(List) = SortedList :-<br /> ( if List = [] then<br /> SortedList = []<br /> else<br /> % Encontrar el mínimo y su índice en la lista<br /> Min = list.min(List),<br /> list.remove(Min, List, RemainingList),<br /> SortedList = [Min | selection_sort(RemainingList)]<br /> ).<br /></code>
								</pre>
							</div>
							<li><a href="https://glot.io/snippets/gxg5cfr7r8" target="_blank" rel="noopener noreferrer">a_star.m</a></li>
							<br />
							<p>
								Este ejemplo implementa el algoritmo de búsqueda A*. Encuentra la ruta óptima entre dos
								nodos en un grafo ponderado.
							</p>
							<div class="code-container">
								<pre>
									<code>:- module a_star.<br />:- interface.<br />:- import_module io.<br />:- pred main(io::di, io::uo) is det.<br /><br />:- implementation.<br />:- import_module list, pair, int, float, map, set, string.<br /><br />% Nodo del grafo<br />:- type node ---> a ; b ; c ; d ; e ; f.<br /><br />% Aristas del grafo y sus costos<br />:- func edges = list(pair(node, list(pair(node, float)))).<br />edges = [a - [(b, 1.0), (c, 3.0)], b - [(d, 1.0)], c - [(d, 1.0), (e, 6.0)], d - [(f, 1.0)], e - [(f, 1.0)]].<br /><br />% Heurística de estimación de costo<br />:- func heuristic(node, node) = float.<br />heuristic(_, _) = 1.0.<br /><br />% Predicado principal<br />main(!IO) :-<br /> % Encontrar la ruta óptima usando A*<br /> ( if a_star(a, f, Route, Cost) then<br /> io.write_string("Ruta encontrada: " ++ string(Route) ++ "\n", !IO),<br /> io.write_string("Costo total: " ++ string(float.to_string(Cost)) ++ "\n", !IO)<br /> else<br /> io.write_string("Ruta no encontrada\n", !IO)<br /> ).<br /><br />% Implementación del algoritmo A*<br />:- pred a_star(node::in, node::in, list(node)::out, float::out) is semidet.<br />a_star(Start, Goal, Route, Cost) :-<br /> edges(Edges),<br /> astar(Edges, heuristic, Start, Goal, Route, Cost).<br /><br />:- pred astar(list(pair(node, list(pair(node, float))))::in, (func(node, node) = float)::in, node::in, node::in, list(node)::out, float::out) is semidet.<br />astar(Edges, Heuristic, Start, Goal, Route, Cost) :-<br /> astar_recursive(Edges, Heuristic, set.init, map.singleton(Start, 0.0), map.singleton(Start, Heuristic(Start, Goal)), Start, Goal, RevRoute, Cost),<br /> Route = list.reverse(RevRoute).<br /><br />:- pred astar_recursive(list(pair(node, list(pair(node, float))))::in, (func(node, node) = float)::in, set(node)::in, map(node, float)::in, map(node, float)::in, node::in, node::in, list(node)::out, float::out) is semidet.<br />astar_recursive(Edges, Heuristic, ClosedSet, GScore, FScore, Current, Goal, [Goal|Route], Cost) :-<br /> Current = Goal,<br /> Cost = map.lookup(GScore, Goal).<br />astar_recursive(Edges, Heuristic, ClosedSet, GScore, FScore, Current, Goal, Route, Cost) :-<br /> Current \= Goal,<br /> findall(Neighbor - (TentativeGScore + Heuristic(Neighbor, Goal)),<br /> ( member(Current - Neighbors, Edges),<br /> member(Neighbor - EdgeCost, Neighbors),<br /> not set.contains(ClosedSet, Neighbor),<br /> TentativeGScore = map.lookup(GScore, Current) + EdgeCost,<br /> ( if not map.search(GScore, Neighbor, NeighborGScore) ; TentativeGScore < NeighborGScore then true else fail<br /> ) ),<br /> OpenSet),<br /> sort(OpenSet, OpenSetSorted),<br /> [Next - _ | _] = OpenSetSorted,<br /> NewGScore = map.set(GScore, Next, TentativeGScore),<br /> NewFScore = map.set(FScore, Next, TentativeGScore + Heuristic(Next, Goal)),<br /> astar_recursive(Edges, Heuristic, set.insert(ClosedSet, Current), NewGScore, NewFScore, Next, Goal, Route, Cost),<br /> Route = [Current | RouteTail].<br /></code>
								</pre>
							</div>
							<li><a href="https://glot.io/snippets/gx6f5maqw7" target="_blank" rel="noopener noreferrer">dijkstra.m</a></li>
							<br>
							<p>
								El siguiente es un ejemplo implementa el algoritmo de Dijkstra para encontrar la ruta más corta en un grafo ponderado:
							</p>
							<div class="code-container">
								<pre>
									<code>:- module dijkstra.<br>:- interface.<br>:- import_module io.<br>:- pred main(io::di, io::uo) is det.<br><br>:- implementation.<br>:- import_module list, pair, int, float, map, set, string.<br><br>% Nodo del grafo<br>:- type node ---> a ; b ; c ; d ; e ; f.<br><br>% Aristas del grafo y sus costos<br>:- func edges = list(pair(node, list(pair(node, float)))).<br>edges = [<br>    a - [(b, 1.0), (c, 4.0)],<br>    b - [(c, 2.0), (d, 5.0)],<br>    c - [(d, 1.0)],<br>    d - [(e, 3.0)],<br>    e - [(f, 1.0)]<br>].<br><br>% Predicado principal<br>main(!IO) :-<br>    % Encontrar la ruta más corta usando Dijkstra<br>    ( if dijkstra(a, f, Route, Cost) then<br>        io.write_string("Ruta encontrada: " ++ string(Route) ++ "\n", !IO),<br>        io.write_string("Costo total: " ++ string(float.to_string(Cost)) ++ "\n", !IO)<br>    else<br>        io.write_string("Ruta no encontrada\n", !IO)<br>    ).<br><br>% Implementación del algoritmo de Dijkstra<br>:- pred dijkstra(node::in, node::in, list(node)::out, float::out) is semidet.<br>dijkstra(Start, Goal, Route, Cost) :-<br>    edges(Edges),<br>    dijkstra_recursive(Edges, map.singleton(Start, 0.0), set.init, map.init, Start, Goal, Route, Cost).<br><br>:- pred dijkstra_recursive(list(pair(node, list(pair(node, float))))::in, map(node, float)::in, set(node)::in, map(node, node)::in, node::in, node::in, list(node)::out, float::out) is semidet.<br>dijkstra_recursive(_, Distances, _, Previous, Current, Goal, Route, Cost) :-<br>    ( if Current = Goal then<br>        reverse(reconstruct_route(Previous, Goal, []), Route),<br>        Cost = map.lookup(Distances, Goal)<br>    else<br>        false<br>    ).<br>dijkstra_recursive(Edges, Distances, Visited, Previous, Current, Goal, Route, Cost) :-<br>    select_min(Distances, Visited, Current, MinDist),<br>    update_neighbors(Edges, Current, MinDist, Distances, Visited, NewDistances, Previous, NewPrevious),<br>    dijkstra_recursive(Edges, NewDistances, set.insert(Current, Visited), NewPrevious, Current, Goal, Route, Cost).<br><br>:- pred select_min(map(node, float)::in, set(node)::in, node::out, float::out) is semidet.<br>select_min(Distances, Visited, MinNode, MinDist) :-<br>    map.foldl((pred(Node::in, Dist::in, !.Acc::in, !:Acc::out) is det :-<br>        ( if not set.contains(Visited, Node) then<br>            ( if Dist < !.Acc^2 then<br>                !:Acc = Node - Dist<br>            else<br>                true<br>            )<br>        else<br>            true<br>        )<br>    ), Distances, pair.init(no, float.max_float), MinNode - MinDist).<br><br>:- pred update_neighbors(list(pair(node, list(pair(node, float))))::in, node::in, float::in, map(node, float)::in, set(node)::in, map(node, float)::out, map(node, node)::in, map(node, node)::out) is det.<br>update_neighbors(Edges, Current, MinDist, Distances, Visited, NewDistances, Previous, NewPrevious) :-<br>    member(Current - Neighbors, Edges),<br>    foldl((pred(NeighborCost::in, !.AccDistances::in, !:AccDistances::out, !.AccPrevious::in, !:AccPrevious::out) is det :-<br>        Neighbor = NeighborCost^1,<br>        Cost = NeighborCost^2,<br>        ( if not set.contains(Visited, Neighbor) then<br>            NewDist = MinDist + Cost,<br>            ( if map.search(!.AccDistances, Neighbor, OldDist) then<br>                ( if NewDist < OldDist then<br>                    map.det_insert(Neighbor, NewDist, !AccDistances),<br>                    map.det_insert(Neighbor, Current, !AccPrevious)<br>                else<br>                    true<br>                )<br>            else<br>                map.det_insert(Neighbor, NewDist, !AccDistances),<br>                map.det_insert(Neighbor, Current, !AccPrevious)<br>            )<br>        else<br>            true<br>        )<br>    ), Neighbors, Distances, NewDistances, Previous, NewPrevious).<br><br>:- func reconstruct_route(map(node, node), node, list(node)) = list(node).<br>reconstruct_route(Previous, Current, Acc) = Route :-<br>    ( if map.search(Previous, Current, Prev) then<br>        Route = reconstruct_route(Previous, Prev, [Current | Acc])<br>    else<br>        Route = [Current | Acc]<br>    ).</code>
								</pre>
							</div>
							<li><a href="https://glot.io/snippets/gx6f5maqw7" target="_blank" rel="noopener noreferrer">topological_sort.m</a></li>
							<br>
							<p>
								Este ejemplo implementa un algoritmo de ordenamiento topológico para detectar ciclos en un grafo dirigido:
							</p>
							<div class="code-container">
								<pre>
									<code>:- module topological_sort.<br>:- interface.<br>:- import_module io.<br>:- pred main(io::di, io::uo) is det.<br><br>:- implementation.<br>:- import_module list, set, map, string.<br><br>% Nodo del grafo<br>:- type node ---> a ; b ; c ; d ; e ; f ; g ; h.<br><br>% Aristas del grafo<br>:- func edges = list(pair(node, list(node))).<br>edges = [<br>    a - [b, c],<br>    b - [d],<br>    c - [d, e],<br>    d - [f],<br>    e - [f, g],<br>    f - [h],<br>    g - [h]<br>].<br><br>% Predicado principal<br>main(!IO) :-<br>    ( if topological_sort(Sorted) then<br>        io.write_string("Orden topológico: " ++ string(Sorted) ++ "\n", !IO)<br>    else<br>        io.write_string("El grafo contiene un ciclo\n", !IO)<br>    ).<br><br>% Implementación del algoritmo de ordenamiento topológico<br>:- pred topological_sort(list(node)::out) is semidet.<br>topological_sort(Sorted) :-<br>    edges(Edges),<br>    list_to_map(Edges, Graph),<br>    topological_sort_recursive(Graph, [], set.init, set.init, Sorted).<br><br>:- pred topological_sort_recursive(map(node, list(node))::in, list(node)::in, set(node)::in, set(node)::in, list(node)::out) is semidet.<br>topological_sort_recursive(Graph, Acc, TempMarked, PermMarked, Sorted) :-<br>    ( if map.is_empty(Graph) then<br>        reverse(Acc, Sorted)<br>    else<br>        map.delete_any(Graph, Node, Neighbors, RestGraph),<br>        ( if set.contains(PermMarked, Node) then<br>            topological_sort_recursive(RestGraph, Acc, TempMarked, PermMarked, Sorted)<br>        else if set.contains(TempMarked, Node) then<br>            false % Se ha encontrado un ciclo<br>        else<br>            topological_sort_visit(Node, Neighbors, RestGraph, [Node | Acc], set.insert(Node, TempMarked), PermMarked, Sorted)<br>        )<br>    ).<br><br>:- pred topological_sort_visit(node::in, list(node)::in, map(node, list(node))::in, list(node)::in, set(node)::in, set(node)::in, list(node)::out) is semidet.<br>topological_sort_visit(Node, [], Graph, Acc, TempMarked, PermMarked, Sorted) :-<br>    topological_sort_recursive(Graph, Acc, set.delete(Node, TempMarked), set.insert(Node, PermMarked), Sorted).<br>topological_sort_visit(Node, [Neighbor | Rest], Graph, Acc, TempMarked, PermMarked, Sorted) :-<br>    ( if set.contains(PermMarked, Neighbor) then<br>        topological_sort_visit(Node, Rest, Graph, Acc, TempMarked, PermMarked, Sorted)<br>    else if set.contains(TempMarked, Neighbor) then<br>        false % Se ha encontrado un ciclo<br>    else<br>        topological_sort_visit(Neighbor, map.lookup(Graph, Neighbor), Graph, Acc, set.insert(Neighbor, TempMarked), PermMarked, TempSorted),<br>        topological_sort_visit(Node, Rest, Graph, TempSorted, TempMarked, PermMarked, Sorted)<br>    ).<br><br>:- pred list_to_map(list(pair(node, list(node)))::in, map(node, list(node))::out) is det.<br>list_to_map(List, Map) :-<br>    foldl((pred(E::in, M0::in, M::out) is det :-<br>        map.det_insert(E^fst, E^snd, M0, M)<br>    ), List, map.init, Map).</code>
								</pre>
							</div>
							<p>
								Ahora veamos ejemplos varios donde vamos a ver criptogramas aritmeticos, un arbol binario y como implementar un sistema basico de gestion de biblioteca:
							</p>
							<p>
								Este ejemplo demuestra cómo resolver criptogramas aritméticos en Mercury, un lenguaje de programación lógico y funcional. Los criptogramas aritméticos consisten en ecuaciones donde los operadores están representados por letras y los operandos son números. El objetivo es encontrar valores para las variables que satisfacen todas las ecuaciones dadas.
							</p>
							<div class="code-container">
							<pre>
							<code>:- module crypt.<br />:- interface.<br />:- import_module io.<br /><br />:- pred main(io::di, io::uo) is det.<br /><br />:- implementation.<br />:- import_module list, int, string.<br /><br />% Predicado principal<br />main(!IO) :-<br /> % Ecuaciones del criptograma<br /> Equations = [[dog, plus, ant, equals, cat], [420, plus, 531, equals, 951]],<br /><br /> % Resolver las ecuaciones<br /> solve(Equations,!IO).<br /><br />% Función para resolver las ecuaciones<br />solve([], _).<br />solve([Equation|Rest], IO) :-<br /> ( if Equation = [X, op, Y, equals, Z] then<br /> find(X, Y, Z, Rest, IO)<br /> else<br /> solve(Rest, IO)).<br /><br />% Función auxiliar para buscar soluciones<br %>find(X, Y, Z, Equations, IO) :-<br %>find(X, Y, Z, Equations, IO, []).<br %>find(_, _, _, [], _).<br %>find(X, Y, Z, [Equation|Rest], IO, Visited) :-<br %> ( if member(Equation, Visited) then<br %> fail<br %> else<br %> ( if Equation = [X, op, Y, equals, Z] then<br %> true<br %> else<br %> find(X, Y, Z, Rest, IO, [Equation|Visited]))<br %> ).<br /></code>
							</pre>
							</div>
							<p>
								Este ejemplo demuestra cómo resolver criptogramas aritméticos en Mercury, un lenguaje de programación lógico y funcional. Los criptogramas aritméticos consisten en ecuaciones donde los operadores están representados por letras y los operandos son números. El objetivo es encontrar valores para las variables que satisfacen todas las ecuaciones dadas.
							</p>
							<div class="code-container">
							<pre>
							<code>:- module crypt.<br />:- interface.<br />:- import_module io.<br /><br />:- pred main(io::di, io::uo) is det.<br /><br />:- implementation.<br />:- import_module list, int, string.<br /><br />% Predicado principal<br />main(!IO) :-<br /> % Ecuaciones del criptograma<br /> Equations = [[dog, plus, ant, equals, cat], [420, plus, 531, equals, 951]],<br /><br /> % Resolver las ecuaciones<br /> solve(Equations,!IO).<br /><br />% Función para resolver las ecuaciones<br />solve([], _).<br />solve([Equation|Rest], IO) :-<br /> ( if Equation = [X, op, Y, equals, Z] then<br /> find(X, Y, Z, Rest, IO)<br /> else<br /> solve(Rest, IO)).<br /><br />% Función auxiliar para buscar soluciones<br %>find(X, Y, Z, Equations, IO) :-<br %>find(X, Y, Z, Equations, IO, []).<br %>find(_, _, _, [], _).<br %>find(X, Y, Z, [Equation|Rest], IO, Visited) :-<br %> ( if member(Equation, Visited) then<br %> fail<br %> else<br %> ( if Equation = [X, op, Y, equals, Z] then<br %> true<br %> else<br %> find(X, Y, Z, Rest, IO, [Equation|Visited]))<br %> ).<br /></code>
							</pre>
							</div>
							<p>
								Este ejemplo demuestra cómo resolver criptogramas aritméticos en Mercury, un lenguaje de programación lógico y funcional. Los criptogramas aritméticos consisten en ecuaciones donde los operadores están representados por letras y los operandos son números. El objetivo es encontrar valores para las variables que satisfacen todas las ecuaciones dadas.
							</p>
							<div class="code-container">
							<pre>
							<code>:- module crypt.<br />:- interface.<br />:- import_module io.<br /><br />:- pred main(io::di, io::uo) is det.<br /><br />:- implementation.<br />:- import_module list, int, string.<br /><br />% Predicado principal<br />main(!IO) :-<br /> % Ecuaciones del criptograma<br /> Equations = [[dog, plus, ant, equals, cat], [420, plus, 531, equals, 951]],<br /><br /> % Resolver las ecuaciones<br /> solve(Equations,!IO).<br /><br />% Función para resolver las ecuaciones<br />solve([], _).<br />solve([Equation|Rest], IO) :-<br /> ( if Equation = [X, op, Y, equals, Z] then<br /> find(X, Y, Z, Rest, IO)<br /> else<br /> solve(Rest, IO)).<br /><br />% Función auxiliar para buscar soluciones<br %>find(X, Y, Z, Equations, IO) :-<br %>find(X, Y, Z, Equations, IO, []).<br %>find(_, _, _, [], _).<br %>find(X, Y, Z, [Equation|Rest], IO, Visited) :-<br %> ( if member(Equation, Visited) then<br %> fail<br %> else<br %> ( if Equation = [X, op, Y, equals, Z] then<br %> true<br %> else<br %> find(X, Y, Z, Rest, IO, [Equation|Visited]))<br %> ).<br /></code>
							</pre>
							</div>	
							<p>
								Este ejemplo demuestra cómo declarar y usar variables en Mercury, un lenguaje de programación lógico y funcional. Se presentan ejemplos de variables enteras, flotantes, cadenas y listas, y se muestran cómo se pueden usar para realizar operaciones básicas de entrada y salida.
							</p>
							<div class="code-container">
							<pre>							
							<code>:- module ejemplo_variables.<br />:- interface.<br />:- import_module io.<br /><br />% Predicado principal<br />:- pred main(io::di, io::uo) is det.<br /><br />% Implementación del módulo<br />:- implementation.<br />:- import_module list.<br /><br />main(!IO) :-<br />    % Declaración de variables<br />    IntVar = 42,<br />    FloatVar = 3.14,<br />    StringVar = "Hola, Mercury",<br />    ListVar = [1, 2, 3, 4, 5],<br /><br />    % Uso de variables y salida<br />    io.write_string("Valor de IntVar: ", !IO),<br />    io.write_int(IntVar, !IO),<br />    io.nl(!IO),<br /><br />    io.write_string("Valor de FloatVar: ", !IO),<br />    io.write_float(FloatVar, !IO),<br />    io.nl(!IO),<br /><br />    io.write_string("Valor de StringVar: ", !IO),<br />    io.write_string(StringVar, !IO),<br />    io.nl(!IO),<br /><br />    io.write_string("Valores de ListVar: ", !IO),<br />    io.write_list(ListVar, ", ", io.write_int, !IO),<br />    io.nl(!IO).<br /></code>							
							</pre>
							</div>	
							<p>
								Este ejemplo demuestra cómo se puede simular el teorema del palomar (o principio del casillero) en Mercury. Se comprueba si hay más palomas que casilleros y se imprime un mensaje correspondiente. 
							</p>
							<div class="code-container">
							<pre>
							<code>:- module main.<br />:- interface.<br />:- import_module io.<br /><br />:- pred main(io::di, io::uo) is det.<br /><br />:- implementation.<br />:- import_module list, int, string, bool.<br /><br />% predicado que verifica el teorema del palomar<br />:- pred pigeonhole(int::in, int::in, bool::out) is det.<br />pigeonhole(N, M, Result) :-<br />    ( if N > M then<br />        Result = yes<br />    else<br />        Result = no<br />    ).<br /><br />% predicado para imprimir el resultado<br />:- pred print_result(int::in, int::in, bool::in, io::di, io::uo) is det.<br />print_result(N, M, Result, !IO) :-<br />    ( if Result = yes then<br />        io.write_string(format("%d palomas en %d casilleros: Al menos un casillero contendrá más de una paloma.\n", [i(N), i(M)]), !IO)<br />    else<br />        io.write_string(format("%d palomas en %d casilleros: Ningún casillero contendrá más de una paloma.\n", [i(N), i(M)]), !IO)<br />    ).<br /><br />main(!IO) :-<br />    % Ejemplos de prueba<br />    Pigeons1 = 10,<br />    Holes1 = 9,<br />    pigeonhole(Pigeons1, Holes1, Result1),<br />    print_result(Pigeons1, Holes1, Result1, !IO),<br /><br />    Pigeons2 = 5,<br />    Holes2 = 5,<br />    pigeonhole(Pigeons2, Holes2, Result2),<br />    print_result(Pigeons2, Holes2, Result2, !IO).<br /></code>
							</pre>
							</div>
						</ul>
						
						<ul class="actions">
							<li><a href="./Ejemplos/Ejemplos.zip" class="button" target="blank">Descargar Zip</a></li>
						</ul>
					</section>

					<section id="six">
						<header class="major">
							<h2>Recursos Extra</h2>
						</header>
						<p>
							Para probar código Mercury online, sugerimos visitar: <a href="https://glot.io/new/mercury" target="blank">https://glot.io/new/mercury</a>
						</p>
						<br>
					</section>
					<section id="seven">
						<p>Creado por:</p>
						<p style="text-align: center;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Juan Castelblanco <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ivan Cepeda <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camilo Rodriguez <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stevan Valbuena <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Samuel Salgado <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diego Bulla</p>
						<p >Ejemplos adicionales por:</p>
						<p style="text-align: center;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Simón Aparicio <br></p>
					</section>
					

				<!-- Four -->
				

			</div>

		<!-- Footer -->
			

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.poptrox.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="assets/js/main.js"></script>

	</body>
</html>
