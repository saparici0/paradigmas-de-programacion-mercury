<!DOCTYPE html>
<html lang="en">

<head style="color: #AAAA;">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">

    <title>Programación Reactiva</title>

    <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" type="text/css" href="fonts/font-awesome-4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="css/stroke.css">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="css/animate.css">
    <link rel="stylesheet" type="text/css" href="css/prettyPhoto.css">
    <link rel="stylesheet" type="text/css" href="css/style.css">

    <link rel="stylesheet" type="text/css" href="js/syntax-highlighter/styles/shCore.css" media="all">
    <link rel="stylesheet" type="text/css" href="js/syntax-highlighter/styles/shThemeRDark.css" media="all">

    <link rel="stylesheet" type="text/css" href="css/custom.css">

    <link rel="stylesheet"
          href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.0.1/build/styles/default.min.css">

</head>

<body>
<button onclick="topFunction()" id="myBtn" title="Go to top"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>

<script>
    var mybutton = document.getElementById("myBtn");
    window.onscroll = function() {scrollFunction()};
    function scrollFunction() {
        if (document.body.scrollTop > 1000 || document.documentElement.scrollTop > 1000) {
            mybutton.style.display = "block";
        } else {
            mybutton.style.display = "none";
        }
    }
    function topFunction() {
        window.scrollTo({ top: 0, behavior: 'smooth' })
        document.documentElement.scrollTo({ top: 0, behavior: 'smooth' })
    }

    document.addEventListener("DOMContentLoaded", () => {
        document.querySelector('#mode').addEventListener('click',()=>{
            document.querySelector('html').classList.toggle('dark');
        })
    });


</script>

<div id="wrapper">

    <div id="mode" >
        <div class="dark">
            <svg aria-hidden="true" viewBox="0 0 512 512">
                <title>lightmode</title>
                <path fill="currentColor" d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"></path>
            </svg>
        </div>
        <div class="light">
            <svg aria-hidden="true" viewBox="0 0 512 512">
                <title>darkmode</title>
                <path fill="currentColor" d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"></path>
            </svg>
        </div>
    </div>

    <div class="container">

        <section id="top" class="section docs-heading">

            <div class="row">
                <div class="col-md-12">
                    <div class="big-title text-center">
                        <h1>Programación Reactiva</h1>
                    </div>
                    <!-- end title -->
                </div>
                <!-- end 12 -->
            </div>
            <!-- end row -->

            <hr>

        </section>
        <!-- end section -->

        <div class="row">

            <div class="col-md-3">
                <nav class="docs-sidebar" data-spy="affix" data-offset-top="300" data-offset-bottom="200" role="navigation">
                    <ul class="nav">
                        <li><a href="#line1">Introducción</a></li>
                        <li><a href="#line3">Características </a></li>
                        <li><a href="#line4">Patrón de Diseño <i>Observer</i> </a></li>
                        <li><a href="#line5">Ventajas </a></li>
                        <li><a href="#line6">Desventajas </a></li>
                        <li><a href="#lineB1">Evolución del paradigma</a></li>
                        <li><a href="#lineB2">El término "Reactive"</a></li>
                        <li><a href="#line7">
                            Programación</a></li>
                        <li><a href="#line8">Ejemplos</a>
                            <ul class="nav">
                                <li><a href="#line8_1">RxPY</a></li>
                                <li><a href="#line8_2">RxJava</a></li>
                                <li><a href="#line8_3">RxJS</a></li>
                                <li><a href="#line8_4">RxRuby</a></li>
                                <li><a href="#line8_5">Rx.NET</a></li>
                                <li><a href="#line8_6">Chat</a></li>
                                <li><a href="#line8_7">RxViz</a></li>
                                <li><a href="#line8_8">Svelte</a></li>
                            </ul>
                        </li>
                        <li><a href="#line9">Aplicaciones</a></li>
                        <li><a href="#line10">Referencias</a></li>
                    </ul>
                </nav >
            </div>
            <div class="col-md-9">


                <section id="line1" class="section" style="padding: 0px;">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Introducción <hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <div class="row">
                        <div class="col-md-12">
                            <h3 class="dark-text">¿Qué es la programación reactiva?</h3>
                            <p>Es un paradigma enfocado en el trabajo con flujos de datos finitos o infinitos de manera asíncrona, es decir que las aplicaciones reaccionan a los cambios ejecutando una serie de eventos.</p>
                            <p>Este paradigma está enfocado principalmente en el manejo de flujos de datos asíncronos y en el uso eficiente de recursos. Los sistemas reactivos reaccionan a los datos que fluyen continuamente ejecutando una serie de eventos, esto es porque siguen el patrón de diseño Observer;
                                cuando hay un cambio de estado en un objeto, los otros objetos son notificados y actualizados. Por lo tanto, en lugar de estar preguntando los cambios, los eventos se realizan de forma asíncrona para que los observadores puedan procesarlos.</p>
                            <p>La motivación detrás de este nuevo paradigma procede de la necesidad de responder a las limitaciones de escalado presentes en los modelos de desarrollo actuales, que se caracterizan por su desaprovechamiento del uso de la CPU debido al I/O,
                                el sobreuso de memoria (enormes thread pools) y la ineficiencia de las interacciones bloqueantes.</p>

                            <img src="images/Observer.svg" alt="" class="img-responsive img-thumbnail">
                            <p> Para el año 2018, la programación reactiva y la programación basada en eventos
                                no eran paradigmas de programación, como la programación imperativa u orientada a objetos, sino que
                                eran ortogonales a ellos. La programación dirigida por eventos se implementa dentro de un paradigma
                                paradigma existente. Por lo tanto, se puede utilizar la programación orientada a eventos con un lenguaje orientado a objetos o
                                un lenguaje funcional. La programación reactiva es un caso específico de la programación de eventos que con el paso de los años ha ido ganando importancia. Esto se puede ver en la siguiente figura:</p>
                            <div class="text-center">
                                <img class="img-responsive img-thumbnail" src="images/diagrama de paradigmas.PNG" alt="">
                            </div>

                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                </section>
                <!-- end section -->

                <section id="line3" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Características<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <h4>Actores</h4>

                    <p><b>Flujo de datos:</b> Son datos que se van modificando cada cierto tiempo, y que puede tener interés observar en tiempo real. A diferencia de los procesos por lotes, donde los datos se recopilan y procesan en bloques, el data streaming permite la ingestión y procesamiento continuo de datos a medida que estos se generan.</p>
                    <p><b>Observable:</b> Un componente que puede ser observado, y que se encargará de informar cuando ese flujo de datos se modifique.</p>
                    <p><b>Observador:</b> Es el elemento que observa esas modificaciones. Cuando el dato se modifica, se notifica al componente que lo está utilizando.
                        Normalmente este observer necesita suscribirse cuando quiere empezar a recibir datos, y desuscribirse cuando ya no le interesan más esos datos.
                    </p>
                    <p><b>Dispatchers:</b> En cada framework de programación reactiva se llaman de una forma distinta, pero básicamente son un conjunto de hilos donde se van a ejecutar las operaciones, y unas reglas que optimizan su uso para ser lo más eficientes posibles.</p>
                    <p><b>Operadores:</b> Son funciones que se aplican a streams de datos haciendo uso de la programación funcional. Implementan soluciones a problemas comunes en el procesamiento de streams como agregar, filtrar, mapear. Existen montones de operadores que nos permiten modificar y combinar flujos de datos, y conocerlos todos es muy complicado. Dependen de las librerías.</p>

                    <hr>

                    <h4>Manejo de flujos de datos</h4>

                    <p>Basado en datos que fluyen continuamente, los sistemas reactivos reaccionan a los datos ejecutando una serie de eventos.</p>

                    <hr>

                    <h4>Patrón de Diseño <i>Observer</i></h4>

                    <p>La programación reactiva sigue el patrón de diseño Observer; cuando hay un cambio de estado en un objeto, los otros objetos son notificados y actualizados acorde. Por lo tanto, en lugar de sondear eventos para los cambios, los eventos se realizan de forma asíncrona para que los observadores puedan procesarlos.</p>

                    <hr>

                    <h4>Uso eficiente de recursos</h4>

                    <p>Utilizando E/S asíncrona, la idea es simple: disminuir el uso ineficiente de recursos usando recursos que de lo contrario estarían inactivos, ya que permanecen a la espera de actividad de E/S. </p>

                    <hr>

                    <h4>Liberación del cliente</h4>

                    <p>Los nuevos datos se notifican a los clientes en vez de tener que solicitarlos, debido a que la E/S asíncrona invierte el diseño normal del procesamiento de E/S. Este enfoque libera al cliente para hacer otras cosas mientras espera nuevas notificaciones.</p>

                    <hr>

                    <h4>Demasiadas notificaciones</h4>

                    <p>Existe el riesgo de que demasiadas notificaciones desborden al cliente. </p>

                    <hr>

                    <h4>Rechazar el trabajo que no se puede manejar</h4>

                    <p>Un aspecto fundamental de control de flujo en sistemas distribuidos es que el cliente debe ser capaz de rechazar el trabajo que no puede manejar. En la programación reactiva, la capacidad del cliente para señalizar cuánto trabajo puede manejar se llama <b>contrapresión</b>. </p>

                </section>
                <!-- end section -->

                <section id="line4" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Patrón de Diseño <i>Observer</i><hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <p>En este patrón, tenemos un objeto Observable al que podemos suscribirnos, y cada vez que haya un cambio en su valor seremos informados. A esto se le conoce como Publicador-Suscriptor. </p>
                    <div class="text-center">
                        <img class="img-responsive img-thumbnail" src="images/patroobserver.png" alt="">
                        <p>Analogía del patrón observador de la vida cotidiana: suscripción al boletín de un portal técnico</p>
                    </div>

                    <h4> Finalidad </h4>

                    <p>El patrón Observer trabaja con dos tipos de actores: por un lado, el sujeto, es decir, el objeto cuyo estado quiere vigilarse a largo plazo. Por otro lado, están los objetos observadores, que han de ser informados de cualquier cambio en el sujeto.
                        Sin el patrón Observer, los objetos observadores tendrían que solicitar al sujeto regularmente que les enviase actualizaciones acerca de su estado (status updates). Cada una de estas solicitudes conllevaría tiempo de computación y requeriría, además, ciertos recursos de hardware.</p>
                    <hr>
                    <h4>Funcionamiento y estructura</h4>
                    <ol type="1">
                        <li>El <b>Notificador</b> envía eventos de interés a otros objetos. Esos eventos ocurren cuando el notificador cambia su estado o ejecuta algunos comportamientos. Los notificadores contienen una infraestructura de suscripción que permite a nuevos y antiguos suscriptores abandonar la lista.</li>
                        <li>Cuando sucede un nuevo evento, el notificador recorre la lista de suscripción e invoca el método de notificación declarado en la interfaz suscriptora en cada objeto suscriptor.</li>
                        <li>La interfaz <b>Suscriptora</b> declara la interfaz de notificación. En la mayoría de los casos, consiste en un único método <i>actualizar</i>. El método puede tener varios parámetros que permitan al notificador pasar algunos detalles del evento junto a la actualización.</li>
                        <li>Los <b>Suscriptores Concretos</b> realizan algunas acciones en respuesta a las notificaciones emitidas por el notificador. Todas estas clases deben implementar la misma interfaz de forma que el notificador no esté acoplado a clases concretas.</li>
                        <li>Normalmente, los suscriptores necesitan cierta información contextual para manejar correctamente la actualización. Por este motivo, a menudo los notificadores pasan cierta información de contexto como argumentos del método de notificación. El notificador puede pasarse a sí mismo como argumento, dejando que los suscriptores extraigan la información necesaria directamente.</li>
                        <li>El <b>Cliente</b> crea objetos tipo notificador y suscriptor por separado y después registra a los suscriptores para las actualizaciones del notificador.</li>
                    </ol>
                    <div class="text-center">
                        <img class="img-responsive img-thumbnail" src="images/structure.png" alt="">
                    </div>


                </section>
                <!-- end section -->


                <section id="line5" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Ventajas<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <h4>Uso eficiente de recursos</h4>

                    <p>En la programación asíncrona clásica, un hilo que se ejecuta pasa la mayor parte de su tiempo esperando. El hilo que se ejecuta envía una petición, por ejemplo, a la base de datos, luego espera durante un periodo de tiempo la respuesta con los datos, cuando finalmente obtiene una respuesta, continúa trabajando y al finalizar vuelve a estar disponible para otra ejecución. Lo que hace que este recurso se esté usando de forma ineficiente.</p>

                    <p>En la programación reactiva cada hilo se centra en enviar la solicitud, y luego vuelve a estar disponible para otra ejecución. Cuando la respuesta llega, este mismo hilo, u otro, puede recoger y procesar la respuesta. En pocas palabras: trata de asegurarse de que todos los hilos estén siempre trabajando en algo, y no esperando.</p>

                    <p>La utilización eficiente de los recursos deriva en gastar menos dinero en servidores y centros de datos. La promesa de la programación reactiva es que se puede hacer más con menos. Específicamente se puede procesar cargas de trabajo más altas con menos hilos.</p>

                    <hr>

                    <h4>Mantenibilidad</h4>

                    <p>La combinación de flujos con potentes operadores resuelve problemas complejos de una manera muy declarativa. El código parecerá conciso y directo; en lugar de ramificaciones verbales y lógica imperativa, se tienen combinaciones de operadores que facilitan hacerse una imagen mental del funcionamiento. Lo cuál, hace más sencillo que cualquier persona diferente al desarrollador original, pueda modificar o mejorar algún aspecto en el código más rápido.</p>

                    <hr>

                    <h4>Escalabilidad</h4>

                    <p>Usando programación reactiva se obtiene una implementación débilmente acoplada, que tiende a aislar los fallos y que tiene la capacidad de escalar horizontalmente y de forma rápida, permitiendo el manejo de grandes cantidades de eventos, que pueden ser millones o billones de eventos, muy útil para “Big Data”.</p>

                    <hr>

                    <h4>Facilidad en el manejo del backpressure</h4>

                    <p>Se pueden dar situaciones donde un Notificador genere más elementos de los que un Suscriptor puede consumir. Lo cual genera que el proceso de convertir esa entrada en salida se resista de alguna manera. En la mayoría de los casos esa resistencia es la velocidad de cálculo.</p>

                    <p>Para manejar estas situaciones en la programación reactiva se han establecido los siguientes mecanismos: Los suscriptores pueden indicar el número de datos que quieren o pueden procesar, de manera que el notificador nunca les enviará más de n cantidad de elementos. Los notificadores pueden aplicar diferentes operaciones como buffers o descartar algunos datos, para evitar saturar a los suscriptores lentos.</p>
                    
                    <p>Backpressure es una solución que implementa el modelo Pull o el patrón de diseño Iterador. Así, hoy día el patrón la programación reactiva implementa dos patrones de diseño : Observer e Iterador</p>
                    
                    <h4>Implementación</h4>

                    <p>Lograr los comportamientos que se logran de forma fácil en el paradigma reactivo, resultan muy complicados y con el uso de artefactos complicados en otros paradigmas de programación.</p>

                    <p>Esta facilidad de implementación se puede evidenciar por la relativa rapida acogida de los componentes reactivos en tecnologías de Front-End, interfaces de usuario y hasta gestores de carga y replicacion en entornos de Cloud.</p>
                
                </section>
                <!-- end section -->

                <section id="line6" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Desventajas<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <h4>Mayor costo en memoria</h4>

                    <p>Este paradigma es más costoso en memoria, porque requiere mayor espacio en memoria para almacenar los flujos de datos (ya que se basa en flujos a lo largo del tiempo).</p>

                    <hr>

                    <h4>Curva de aprendizaje</h4>

                    <p>La curva de aprendizaje es grande para dominar la programación reactiva. No sólo se está expuesto a un ecosistema completamente nuevo con nuevas APIs, sino que también se necesita tiempo para procesar este paradigma diferente de programación con streams, que puede ser bastante diferente de un estilo de código de escritura tradicional (por ejemplo, en comparación con la programación imperativa). También puede que se necesite aprender de nuevas herramientas para las pruebas unitarias y dominar conceptos adicionales como los diagramas de mármol, que ayudan a modelar adecuadamente los flujos de datos. Además, hay una falta de recursos buenos y sencillos para aprender.</p>

                    <hr>

                    <h4>Depurar no es más fácil</h4>

                    <p>Del mismo modo que en la programación clásica donde nos podemos encontrar con un espagueti de funciones. En la programación reactiva también se puede encontrar un espagueti de flujos y no saber qué camino tomar. Con las funciones simples suele ser más sencillo hacer una depuración del código, dado que se componen secuencialmente. Con los flujos, puede que no sea tan sencillo porque no existe tal cosa como un flujo que invoca a otro flujo. En su lugar, se tiene un flujo que se conecta con otros flujos de maneras mixtas dependiendo de los operadores que los unen.</p>

                    <hr>

                    <h4>Acumulación de delay</h4>

                    <p>Los sistemas reactivos pueden acumular fácilmente retrasos debido a un número excesivo de procesos vinculados al flujo.</p>

                </section>
                <!-- end section -->

                <section id="lineB1" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Evolución del paradigma<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <p>
                        Los orígenes de la programación reactiva se remontan, probablemente, a la década de 1970,
                        pero esta empezó a resonar en la década del 2010, al mismo tiempo que comenzó el auge de
                        los microservicios y los procesadores multinúcleo.
                        <br><br>
                        Desde entonces, dicho paradigma ha evolucionado de manera significativa y, por este motivo,
                        las librerías que lo implementan pueden clasificarse en generaciones de acuerdo a su grado
                        de madurez, según la categorización propuesta por el autor
                        <a href="https://hu.linkedin.com/in/david-karnok-725b3189">
                            David Karnok</a> en el año 2016, la cual se describe a continuación:
                    </p>

                    <hr>

                    <h4>Orígenes</h4>
                    <p>
                        En las primeras aplicaciones de GUI, la interfaz se actualizaba solo después de una acción del usuario, 
                        como hacer clic en un botón. El núcleo de la aplicación era un bucle de eventos que esperaba sincrónicamente la 
                        entrada del usuario, lo que hacía que la aplicación se colgara si no había interacción.
                        <br><br>

                        La solución es desacoplar el manejo de eventos de la actualización de la GUI, utilizando una cola de eventos 
                        y un procesamiento paralelo. En este patrón productor-consumidor, un hilo maneja la entrada del usuario y coloca 
                        eventos en la cola, mientras otro hilo consume estos eventos y actualiza la GUI.

                    </p>
                    <hr>

                    <h4>Generación 0</h4>

                    <p>
                        Consiste, principalmente, de la API <b>java.util.Observable</b> y de otras API basadas en
                        <i>callbacks</i>, tal como <b>addXXXListener</b> en Swing, AWT y Android. <br><br>
                        Los inconvenientes que presentaban las herramientas de esta generación eran las
                        deficiencias de composición y el hecho de que, por sí mismas, resultaban bastante limitadas.
                    </p>

                    <hr>

                    <h4>Primera generación</h4>

                    <p>
                        Una vez que Erik Meijer y el equipo de Microsoft reconocieron y abordaron las deficiencias,
                        nació la primera generación de bibliotecas de programación reactiva: Rx.NET alrededor de
                        2010, Reactive4Java en 2011 y las primeras versiones de RxJava en 2013.
                        <br><br>
                        Algunos de los inconvenientes encontrados consistieron en que, al implementar las interfaces
                        <b>IObservable/IObserver</b> no se podían cancelar las secuencias en ejecución usando
                        el operador <b>take()</b>, además del problema de la falta de <i>backpressure</i>.
                    </p>

                    <hr>

                    <h4>Segunda generación</h4>

                    <img src="images/subscribe.png" alt="" class="img-responsive img-thumbnail">

                    <p>
                        El equipo de RxJava identificó estas deficiencias y se diseñó una nueva arquitectura. En
                        esta se introdujo: la clase <b>Subscriber</b>, la cual puede decir si está interesada
                        en más eventos o no; la interfaz <b>Producer</b>, para señalar la cantidad de elementos
                        que un <i>Subscriber</i> puede procesar a la vez, y el método <b>lift()</b>, que permite una
                        transformación funcional entre <i>Subscribers</i>.
                        <br><br>
                        No obstante, esta solución era un poco torpe y limitaba algunas optimizaciones, además
                        de que era incompatible con los puntos de vista de otras bibliotecas reactivas que
                        comenzarían a surgir más adelante.
                    </p>

                    <hr>

                    <h4>Tercera generación</h4>

                    <p>
                        Ingenieros de varias compañías se juntaron y crearon la especificación <b>Reactive
                        Streams</b>. Algunos ejemplos de librerías que pertenecen a esta generación son
                        RxJava 2.x, Project Reactor y Akka-Streams.
                    </p>

                    <hr>

                    <h4>Cuarta generación</h4>

                    <p>
                        Algunas de estas librerías se reimplementaron, lo cual condujo al establecimiento de
                        la librería <i>reactive-streams-commons</i>, a la construcción de ciertos operadores
                        fundacionales y al diseño de componentes de optimización que pasaron a recibir el nombre
                        de <b>operator-fusion</b>. Comparada con la generación anterior, aunque lucen similares
                        en el exterior, en el interior poseen cambios significativos que permitieron una
                        reducción aún mayor de los gastos generales.
                    </p>

                    <hr><br>

                    <p>
                        Adicionalmente, este autor especula que, de la quinta generación en adelante, la arquitectura
                        de <i>Reactive-Streams</i> requeriría ciertas extensiones para soportar operaciones
                        reactivas de entrada y salida en la forma de secuencias bidireccionales, entre otros
                        cambios que, en ese punto, estaban abiertos a discusión.
                    </p>


                </section>
                <!-- end section -->

                <section id="lineB2" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">El término "Reactive"<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <p>
                        La programación reactiva, al tratarse de un paradigma emergente que está en constante
                        actualización, suele confundirse con otros conceptos que también llevan la partícula
                        "reactive" en su nombre. Este término es muy amplio y, aunque algunas personas pueden
                        creer que las extensiones reactivas, los <i>streams</i> reactivos, los sistemas reactivos,
                        y la programación funcional reactiva (entre otras muchas) sean lo mismo, la verdad es
                        que existen diferencias importantes a considerar en todas ellas.
                    </p>

                    <hr>

                    <h4>Programación Funcional Reactiva (FRP)</h4>

                    <p>Es un paradigma de programación que combina los principios
                         de la programación funcional con el manejo de datos que cambian a lo largo del tiempo de manera 
                         continua. En lugar de trabajar con valores discretos emitidos a lo largo del tiempo, como en la 
                         programación reactiva tradicional, la FRP se enfoca en representar y manipular valores que pueden 
                         variar continuamente. Este enfoque permite describir comportamientos dinámicos y sistemas interactivos
                          de forma declarativa, facilitando el desarrollo de aplicaciones como animaciones, simulaciones y 
                         gráficos interactivos.
                        </p>

                    <p>
                        Fue definida en 1997 por <a href="http://conal.net/">Conal Elliott</a> y Paul Hudak. De
                        acuerdo con una presentación que Elliott dio en el año 2015, titulada "The essence and
                        origins of FRP", el término había sido empleado incorrectamente para describir sistemas
                        como Elm, Bacon y extensiones reactivas. La diferencia principal entre la FRP y la
                        programación reactiva es que la primera opera en valores que cambian continuamente a
                        través del tiempo, mientras que la segunda opera en valores discretos que se emiten a
                        través del tiempo. La conferencia puede verse a continuación:
                    </p>

                    <video class="img-responsive img-thumbnail" src="https://vod-progressive.akamaized.net/exp=1642988475~acl=%2Fvimeo-prod-skyfire-std-us%2F01%2F1844%2F5%2F134223272%2F395828977.mp4~hmac=6265b1468e2174bceb3fbc2ec8c6f79cca230503d3abd79b8ab5a7437fccd296/vimeo-prod-skyfire-std-us/01/1844/5/134223272/395828977.mp4?filename=frp+final.mp4" controls></video>

                    <hr>

                    <h4>Extensiones y Streams Reactivos</h4>

                    <p>
                        Las extensiones reactivas, mejor conocidas como <b>"ReactiveX"</b> son un conjunto de
                        herramientas que implementan el paradigma de la programación reactiva (estas se cubrirán
                        a detalle <a href="#line7">más adelante</a>). <br><br>
                        Sin embargo, debido a que estas contienen una gran variedad de librerías y a la falta
                        de interoperabilidad entre ellas, surgieron los <i>Reactive Streams</i>. Esta fue una
                        iniciativa creada para proveer un estándar para las extensiones reactivas y
                        que lidiara con el procesamiento de flujo (<i>stream</i>) asincrónico con contrapresión
                        sin bloqueo (<i>non-blocking backpressure</i>); es decir, se buscó unificar las
                        librerías ya existentes.
                    </p>

                    <hr>

                    <h4>Operadores sobre Streams reactivos</h4>

                    <h5>
                        Operadores de creación
                    </h5>

                    <p>
                        <b>of:</b> Crea un stream a partir de una lista de elementos.

                    </p>
                    <p>
                        <b>from:</b> Convierte varios tipos de datos (arrays, promesas, iterables) en streams.
                    </p>
                    <p>
                        <b>interval:</b> Emite números secuenciales a intervalos de tiempo específicos.
                    </p>

                    <p>
                        <b>timer:</b> Emite un valor después de un tiempo determinado.
                    </p>

                    <h5>Operadores de join</h5>

                    <p><b>merge:</b> Combina múltiples streams emitiendo todos los valores a medida que ocurren.</p>
                    <p><b>concat:</b> Emite todos los valores de un stream y luego continúa con el siguiente.</p>
                    <p><b>combineLatest:</b> Combina múltiples streams emitiendo el último valor de cada uno cada vez que uno de los streams emite.</p>
                    <p><b>zip:</b> Combina valores de múltiples streams en forma de tuplas, emitiendo cada vez que cada stream ha emitido un valor.</p>

                    <h5>Operadores de transformación</h5>

                    <p><b>map:</b> Aplica una función a cada valor emitido por el stream.</p>
                    <p><b>scan:</b> Acumula valores emitidos utilizando una función acumuladora, similar a <code>reduce</code> en arreglos.</p>
                    <p><b>buffer:</b> Agrupa los valores emitidos en arrays.</p>

                    <h5>Operadores de filtrado</h5>
                    <p><b>filter:</b> Emite solo los valores que cumplen con una condición específica.</p>
                    <p><b>debounceTime:</b> Emite un valor solo si ha pasado una cierta cantidad de tiempo desde la última emisión.</p>
                    <p><b>distinctUntilChanged:</b> Emite valores solo si son diferentes del valor anterior.</p>

                    <h5>Operadores de multicasting</h5>
                    <p><b>share:</b> Convierte un stream en un stream multicast compartido entre suscriptores.</p>
                    <p><b>publish:</b> Convierte un stream en un connectable observable que puede ser controlado cuándo empezar a emitir.</p>
                    <p><b>refCount:</b> Convierte un connectable observable en un observable regular que se suscribe y se desuscribe automáticamente basado en la cantidad de suscriptores.</p>

                    <h4>Sistemas reactivos</h4>

                    <p>
                        Los sistemas reactivos son un conjunto de principios de diseño arquitectónico para construir
                        sistemas modernos que estén bien preparados para satisfacer las crecientes demandas que
                        enfrentan las aplicaciones hoy en día. Sus especificaciones se pueden encontrar en línea
                        bajo el nombre de "Manifiesto Reactivo", tal como sigue a continuación:
                    </p>

                    <div class="intro2 clearfix">
                        <p>Los Sistemas Reactivos son:</p>
                        <p><b>Responsivos:</b> El sistema responde a tiempo en la medida de lo posible. La responsividad es la piedra angular de la usabilidad y la utilidad, pero más que esto, responsividad significa que los problemas pueden ser detectados con rapidez y tratados efectivamente. Los sistemas responsivos se enfocan en proveer tiempos de respuesta rápidos y consistentes, estableciendo límites superiores confiables para así proporcionar una calidad de servicio consistente. Este comportamiento consistente, a su vez, simplifica el tratamiento de errores, aporta seguridad al usuario final y fomenta una mayor interacción.</p>
                        <p><b>Resilientes:</b> El sistema permanece responsivo frente a fallos. Esto es aplicable no sólo a sistemas de alta disponibilidad o de misión crítica - cualquier sistema que no sea resiliente dejará de ser responsivo después de un fallo. La resiliencia es alcanzada con replicación, contención, aislamiento y delegación. Los fallos son manejados dentro de cada componente, aislando cada componente de los demás, y asegurando así que cualquier parte del sistema pueda fallar y recuperarse sin comprometer el sistema como un todo. La recuperación de cada componente se delega en otro componente (externo) y la alta disponibilidad se asegura con replicación allí donde sea necesario. El cliente de un componente no tiene que responsabilizarse del manejo sus fallos.</p>
                        <p><b>Elásticos:</b> El sistema se mantiene responsivo bajo variaciones en la carga de trabajo. Los Sistemas Reactivos pueden reaccionar a cambios en la frecuencia de peticiones incrementando o reduciendo los recursos asignados para servir dichas peticiones. Esto implica diseños que no tengan puntos de contención o cuellos de botella centralizados, resultando en la capacidad de dividir o replicar componentes y distribuir las peticiones entre ellos. Los Sistemas Reactivos soportan algoritmos de escalado predictivos, así como Reactivos, al proporcionar relevantes medidas de rendimiento en tiempo real. La elasticidad se consigue de forma rentable haciendo uso de plataformas con hardware y software genéricos.</p>
                        <p><b>Orientados a Mensajes:</b> Los Sistemas Reactivos confían en el intercambio de mensajes asíncrono para establecer fronteras entre componentes, lo que asegura bajo acoplamiento, aislamiento y transparencia de ubicación. Estas fronteras también proporcionan los medios para delegar fallos como mensajes. El uso del intercambio de mensajes explícito posibilita la gestión de la carga, la elasticidad, y el control de flujo, gracias al modelado y monitorización de las colas de mensajes en el sistema, y la aplicación de back-pressure cuando sea necesario. La mensajería basada en ubicaciones transparentes como medio de comunicación permite que la gestión de fallos pueda trabajar con los mismos bloques y semánticas a través de un clúster o dentro de un solo nodo. La comunicación No-bloqueante permite a los destinatarios consumir recursos sólo mientras estén activos, llevando a una menor sobrecarga del sistema.</p>
                        <p><br> Publicado en septiembre 16 2014. (v2.0) <a href="https://www.reactivemanifesto.org/es" target="_blank">El Manifiesto de Sistemas Reactivos.</a> </p>

                    </div>

                    <p>
                        Esta es uno de los conceptos que suele causar más confusiones, debido al hecho de que <b>usar
                        programación reactiva no necesariamente conduce a la formación de sistemas reactivos</b>. Aunque
                        el paradigma sí es útil para satisfacer ciertos requerimientos enunciados en el manifiesto, hace
                        falta considerar algunos puntos: <br><br>
                        De acuerdo al <i>white paper</i> "Reactive Programming versus Reactive Systems", escrito por
                        <a href="http://jonasboner.com/">Jonas Bonér</a> y <a href="https://viktorklang.com/">Viktor Clang</a>,
                        la programación reactiva es, generalmente, dirigida por eventos, mientras que los sistemas
                        reactivos son dirigidos por mensajes. La principal diferencia entre ambos consiste en que los
                        mensajes son inherentemente dirigidos (siempre tienen un destino), mientras que los eventos no:
                        estos son tan solo señales emitidas por un componente al alcanzar cierto estado.
                    </p>

                    <img src="images/soapbox.jpg" class="img-responsive img-thumbnail" alt="">

                    <p>
                        En un sistema dirigido por mensajes, los receptores esperan por la llegada de estos y reaccionan
                        a ellos, de lo contrario permanecen inactivos. Por otra parte, en un sistema dirigido por eventos,
                        los detectores de notificaciones están anclados a las fuentes de dichos eventos, de tal forma que
                        son invocados cuando el evento es emitido. En síntesis, un sistema dirigido por mensajes se centra
                        en los destinatarios, mientras que uno dirigido por eventos se enfoca en los emisores. <br><br>
                        De este modo, el uso exclusivo de programación reactiva puede hacer que la resiliencia sea más
                        difícil de lograr, pues las <i>callbacks</i> suelen ser anónimas y, por ende, no direccionables.
                        Es decir que, si falla una de las cadenas del flujo de datos, entonces se debe reiniciar la cadena
                        y el cliente debe ser notificado (algo que no ocurre en un sistema dirigido por mensajes, que
                        tendría la capacidad de autorrecuperarse sin involucrar al cliente). Sin embargo, si se integra
                        este paradigma con una arquitectura reactiva, este termina siendo de gran utilidad a la hora
                        de construir sistemas reactivos.
                    </p>

                </section>
                <!-- end section -->

                <section id="line7" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">
                                Programación <hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <div class="row">
                        <div class="col-md-6">
                            <h3>ReactiveX</h3>
                            <p>Es un conjunto de herramientas que permiten que los
                                programación imperativos operen en secuencias de datos independientemente de si los datos son síncronos o asincrónicos. Proporciona un conjunto de operadores de secuencia que operan en cada elemento de la secuencia. Es una implementación de programación reactiva y proporciona un modelo para que las herramientas se implementen en múltiples
                                programación.
                            </p>
                            <p>ReactiveX es una combinación de las mejores ideas del patrón Observer, el patrón Iterator y la programación funcional Reactiva.</p>

                            <img src="images/reactivex.png" alt="" class="img-responsive img-thumbnail">

                        </div>

                        <div class="col-md-6">
                            <h3>Lenguajes con librería ReactiveX</h3>

                            <p> Los siguientes lenguajes poseen una librería basada en ReactiveX que les permite pertenecer al paradigma de la Programación reactiva </p>
                            <ul>
                                <li>Java: <a href="https://github.com/ReactiveX/RxJava">RxJava</a></li>
                                <li>JavaScript: <a href="https://github.com/ReactiveX/rxjs">RxJS</a></li>
                                <li>C#: <a href="https://github.com/Reactive-Extensions/Rx.NET">Rx.NET</a></li>
                                <li>C#(Unity): <a href="https://github.com/neuecc/UniRx">UniRx</a></li>
                                <li>Scala: <a href="https://github.com/ReactiveX/RxScala">RxScala</a></li>
                                <li>Clojure: <a href="https://github.com/ReactiveX/RxClojure">RxClojure</a></li>
                                <li>C++: <a href="https://github.com/Reactive-Extensions/RxCpp">RxCpp</a></li>
                                <li>Lua: <a href="https://github.com/bjornbytes/RxLua">RxLua</a></li>
                                <li>Ruby: <a href="https://github.com/Reactive-Extensions/Rx.rb">Rx.rb</a></li>
                                <li>Python: <a href="https://github.com/ReactiveX/RxPY">RxPY</a></li>
                                <li>Go: <a href="https://github.com/ReactiveX/RxGo">RxGo</a></li>
                                <li>Groovy: <a href="https://github.com/ReactiveX/RxGroovy">RxGroovy</a></li>
                                <li>JRuby: <a href="https://github.com/ReactiveX/RxJRuby">RxJRuby</a></li>
                                <li>Kotlin: <a href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a></li>
                                <li>Swift: <a href="https://github.com/kzaher/RxSwift">RxSwift</a></li>
                                <li>PHP: <a href="https://github.com/ReactiveX/RxPHP">RxPHP</a></li>
                                <li>Elixir: <a href="https://github.com/alfert/reaxive">reaxive</a></li>
                                <li>Dart: <a href="https://github.com/ReactiveX/rxdart">RxDart</a></li>
                            </ul>

                            <strong>ReactiveX para plataformas y frameworks</strong>
                            <br/>
                            <ul>
                                <li>Netty: <a href="https://github.com/ReactiveX/RxNetty">RxNetty</a></li>
                                <li>Android: <a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a></li>
                                <li>Cocoa: <a href="https://github.com/ReactiveX/RxSwift">RxCocoa</a></li>
                                <li>ROS: <a href="https://github.com/rosin-project/rxros">RxROS</a></li>
                            </ul>
                        </div>
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="col-md-2 right-align">
                        <img src="images/spring.png" class="img-responsive img-thumbnail" alt="">
                    </div>
                    <!-- end col -->

                    <div class="row">
                        <div style="margin-top: 30px;" class="col-md-4 left-align">
                            <h4>Spring framework 5.0</h4>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <p>
                        Spring 5 incluye Spring WebFlux, que proporciona soporte de programación reactiva para aplicaciones web.
                    </p>
                    <p>
                        Spring WebFlux permitirá construir un servicio REST no bloqueante, de tal forma que se puedan hacer varias
                        peticiones simultáneas y estas se procesen en paralelo.
                    </p>

                    <hr>

                    <div class="col-md-2 right-align">
                        <img src="images/svelte.png" class="img-responsive img-thumbnail" alt="">
                    </div>
                    <!-- end col -->

                    <div class="row">
                        <div style="margin-top: 45px;" class="col-md-4 left-align">
                            <h4>Svelte</h4>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <p>
                        Svelte presenta un enfoque nuevo para crear interfaces de usuario. Mientras los frameworks tradicionales como React y Vue hacen la mayor parte de su trabajo en el navegador, Svelte cambia ese trabajo a un paso de compilación que ocurre cuando se construye la aplicación.
                    </p>

                    <p>
                        Se podría decir que Svelte es un compilador que toma el código y genera JavaScript nativo que interactúa con el DOM directamente sin necesidad de un intermediario.
                    </p>

                </section>
                <!-- end section -->

                <section id="line8" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Ejemplos<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_1">RxPY </h4>

                            <script src="https://gist.github.com/juankg214/e0f5ed1550993577ea302edbf10e775a.js"></script>

                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_2">RxJAVA </h4>

                            <script src="https://gist.github.com/juankg214/8b2862d91b272338c2fed1ecc580f0eb.js"></script>
                            <script src="https://gist.github.com/juankg214/a340b74659748cd55f194b67092ea6d6.js"></script>
                            <script src="https://gist.github.com/juankg214/72b16f25698e603d329637bbb2cee74f.js"></script>
                            <p>El siguiente ejemplo muestra una implementación pura en Java que busca simular un caso de programación reactiva,
                                en el que en un hilo se simula el envío de un correo a una dirección de correo aleatoria y en otro hilo se simula
                                la confirmación de la recepción de dicho email</p>
                            <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@Jaider_AndresAn/ExampleWithOutRXJava?embed=true"></iframe>
                            <p>Ahora, el mismo ejemplo pero usando RxJava</p>
                            <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@Jaider_AndresAn/RxJava?embed=true"></iframe>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_3">RxJS </h4>
                            <p>A continuación, veremos un ejemplo simple de reactividad en <strong>Javascript</strong><br>
                                Iniciamos definiendo dos funciones:
                            <li>UpdateNotifications: Encargada de notificarnos cuando el usuario fue actualizado</li>
                            <li>GetUsers: La cual nos genera un usuario aleatorio</li>
                            En este primer ejemplo el usuario se creará sin problemas y seguido de esto será actualizado mediante el bucle <strong>for</strong>.
                            <script src="https://gist.github.com/BryGuz/0e86a967944f3b44d9403bb6156ab2a0.js"></script>
                            Ahora bien, ¿Qué ocurriría si en vez de un cliente tenemos un flujo de clientes continuo?
                            <strong>¡Correcto!</strong>, Al no terminar de crear clientes, el bucle for jamás llega a ejecutarse.
                            <script src="https://gist.github.com/BryGuz/aa37f4b361730ebc42819016a7b5023e.js"></script>
                            Una forma de solucionar este problema puede ser obligar la ejecución del programa mediante otra sentencia <strong>SetInterval</strong> y mejorándolo un poco, como vemos a continuación; ajustando el index desde el que se recorrerá la lista de usuarios.<br>
                            Sin embargo está solución puede ser implementada utilizando programación reactiva de manera más elegante y <strong>¡Menos código!</strong>
                            <script src="https://gist.github.com/BryGuz/89c1511eb138b985af75b5a1af291ec9.js"></script>
                            Como observamos a continuación debemos declarar un <strong>Observador</strong> que será el encargado de avisarnos cuando se crea un nuevo usuario y comunicarlo al <strong>Suscribe</strong>, el cual se ejecutará apenas el estado de la lista cambie.
                            <script src="https://gist.github.com/BryGuz/01e86ca59de45213615fd219058de169.js"></script>
                            </p>





                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_4">RxRuby </h4>
                            <p>El siguiente ejemplo crea un observable que emite números secuenciales, uno cada 2 segundos, luego estos son capturados
                                por el suscriptor y ejecutada la función según el caso</p>
                            <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@Jaider_AndresAn/RXRuby?embed=true"></iframe>

                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_5">Rx.NET </h4>
                            <p>El siguiente ejemplo crea 2 Observables, cada uno de un único elemento, luego los combina realizando la suma de los
                                valores y selecciona la respuesta como String en caso de que la suma sea par, esta combinación se muestra
                                tanto haciendo uso de sintaxis basada en Queries como en sintaxis fluida</p>
                            <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@Jaider_AndresAn/RxNET?embed=true"></iframe>

                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->
                    
                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_6">Ejemplo de chat usando programación reactiva </h4>
                            <script src="https://gist.github.com/nestorsgarzonc/6e39658f7f354fc497cee69e378833aa.js"></script>
                            <iframe src="https://reactive-programming-examples.vercel.app/" frameborder="0" height="600" width="350"></iframe>

                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_7">Ejemplos varios en RxViz</h4>
                            <p> En el siguiente enlace se pueden encontrar algunos ejemplos proveidos por el equipo de RxViz.</p>
                            <a href="https://rxviz.com/">https://rxviz.com/</a>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>
                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_8">Ejemplo en Svelte</h4>
                            <p> En el siguiente link se puede acceder a un repositorio que contiene el ejemplo presentado a continuación.</p>
                            <a href="https://github.com/facaslo97/SvelteExample">https://github.com/facaslo97/SvelteExample</a>
                            <p> En las siguientes imagenes podemos observar como implementar una sencilla interfaz web para un servicio de libreria </p>
                            <p>Estructura del proyecto</p>
                            <p>En la carpeta source es donde se van a colocar todos los archivos con extensión .svelte que corresponden a componentes de la interfaz gráfica</p>
                            <img src="images/svelteexample/Screenshot from 2023-05-16 21-06-32.png" class="img-responsive img-thumbnail">
                            <p>Componente libro</p>
                            <p>La sintaxis de svelte es una extensión de HTML, CSS y JavaScript. Dentro de la etiqueta script se va a añadir toda la funcionalidad reactiva. En este caso declaramos 3 variables
                                que corresponden a los campos título, precio y descripción.
                            </p>
                            <img src="images/svelteexample/Screenshot from 2023-05-16 21-15-15.png" class="img-responsive img-thumbnail">
                            <p>Componente botón</p>
                            <p>En esta imagen podemos observar como se agregan los estilos CSS dentro de las etiquetas style. Adicionalmente todo lo que no esté dentro de una etiqueta style o una script es inmediatamente interpretado como
                                contenido HTML para el componente. En este caso un botón cuyo atributo on:clic indica que el flujo de datos va a ser cambiado cuando se de un evento de clic.
                                La etiqueta slot indica que se pueden anidar mas componentes svelte dentro de nuestro componente botón.
                            </p>
                            <img src="images/svelteexample/Screenshot from 2023-05-16 21-18-15.png" class="img-responsive img-thumbnail">
                            <p>Componente app</p>
                            <p>El componente app es el componente central de la aplicación. Dentro de script se observa como se hace un llamado a los otros 2 componentes, libro y botón. De igual forma
                                se declaran unas variables que corresponden a los campos del libro, una lista que va a contener componentes de tipo libro, así como 2 funciones que se van a encargar
                                de actualizar la información según el flujo de datos. Observamos también que para hacer referencia a las variables reactivas del componente libro dentro del contenido HTML se 
                                encierra el nombre de la variable dentro de llaves. Svelte también permite usar condicionales y ciclos iterativos como se observa en la 3ra imagen.
                            </p>
                            <img src="images/svelteexample/Screenshot from 2023-05-16 21-23-40.png" class="img-responsive img-thumbnail">
                            <img src="images/svelteexample/Screenshot from 2023-05-16 21-27-05.png" class="img-responsive img-thumbnail">
                            <img src="images/svelteexample/Screenshot from 2023-05-16 21-29-19.png" class="img-responsive img-thumbnail">
                            <p>Main.js</p>
                            <p>Este script es el que se encarga de actualizar el DOM de acuerdo al componente app que hemos definido con anterioridad.</p>
                            <img src="images/svelteexample/Screenshot from 2023-05-16 21-33-00.png" class="img-responsive img-thumbnail">
                            <p>Ejecución</p>
                            <p>Agregar un libro tras llenar los campos y pulsar el botón añadir actualiza inmediatamente la lista de libros sin tener que hacer ninguna petición a un servidor.</p>
                            <img src="images/svelteexample/Screenshot from 2023-05-16 21-36-15.png" class="img-responsive img-thumbnail">
                            <img src="images/svelteexample/Screenshot from 2023-05-16 21-39-25.png" class="img-responsive img-thumbnail">
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>
                    <hr>
                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_8">Ejemplo en Svelte - Calculadora de PAPI</h4>
                            <p> En el siguiente link se puede acceder a un repositorio que contiene el ejemplo presentado a continuación.</p>
                            <a href="https://github.com/josmedinaca/calculadora-papi">https://github.com/josmedinaca/calculadora-papi</a>
                            <p> En las siguientes imágenes podemos observar cómo implementar una Calculadora responsive que se encarga de darnos nuestro PAPI </p>
                            <p>Estructura del proyecto</p>
                            <img src="images/svelteexample/papi-01.png" class="img-responsive img-thumbnail">
                            <p>Componente SubjectForm</p>
                            <p>Este componente se encarga de añadir la asignatura, asi como sus créditos, nota y si fue cancelada o no.
                            </p>
                            <img src="images/svelteexample/papi-02.png" class="img-responsive img-thumbnail">
                            <p>Componente SubjectsList</p>
                            <p>Este componente se encarga de mostrarnos a manera de tabla las asignaturas que hemos ido añadiendo para realizar nuestro cálculo de papi, de igual forma en esta sección se pueden eliminar asignaturas.
                            </p>
                            <img src="images/svelteexample/papi-03.png" class="img-responsive img-thumbnail">
                            <p>Componente app</p>
                            <p>El componente app es el componente central de la aplicación. Dentro de script se observa cómo se hace un llamado a los otros 2 componentes, SubjectForm y SubjectsList.
                                En esta parte realizamos el cálculo del papi y lo imprimimos en la pantalla del usuario.
                            </p>
                            <img src="images/svelteexample/papi-04.png" class="img-responsive img-thumbnail">

                            <p>Ejecución</p>
                            <p>Podemos ver el papi despues de añadir 2 asignaturas y 1 de ellas fue cancelada.</p>
                            <img src="images/svelteexample/papi-05.png" class="img-responsive img-thumbnail">
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>
                </section>
                <!-- end section -->

                <section id="line9" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Aplicaciones<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <div class="row">
                        <div class="col-md-6">

                            <strong>Dominios de Aplicación:</strong>
                            <p>Muchas empresas están utilizando esta forma de programación actualmente y con mucha razón. Como ya hemos señalado, permite crear aplicaciónes o sitios web de tal manera que ofrece una mejor experiencia de usuario. Resultados más suaves y rápidos provienen de este paradigma y hace que la interacción del usuario sea mucho mejor. Naturalmente, esto se traduce en clientes más felices y más ventas para el negocio.</p>

                            <p>Compañías como <strong>Netflix</strong> llevan años aplicando la programación reactiva para mejorar el rendimiento de sus aplicaciones, superando las limitaciones nativas de múltiples lenguajes. Reactivex y otras librerías les proporcionó la pieza que necesitaban para realizar la orquestación de microservicios, la implementación del patrón <a href="https://martinfowler.com/bliki/CircuitBreaker.html"><strong>circuit breaker</strong></a> y demás mecanismos que permiten a sus desarrollos adoptar los principios descritos por el manifiesto reactivo.</p>

                            <p> <strong>Capital One</strong> rediseñó su aplicación de préstamos para automóviles en torno a los principios Reactivos para simplificar la compra y financiación de automóviles en línea. Los clientes pueden navegar por más de cuatro millones de automóviles de más de 12.000 concesionarios y precalificar el financiamiento en segundos, sin afectar las puntuaciones de crédito.</p>
                            <p> <strong>LinkedIn</strong> recurrió a los principios Reactivos para crear indicadores de presencia en tiempo real (indicadores en línea) para el medio billón de usuarios de su red social.</p>
                            <p> <strong>Verizon Wireless</strong>, operadores de la red 4G LTE más grande en Estados Unidos, redujo los tiempos de respuesta a la mitad utilizando los principios de Reactive en la actualización de su sitio web de comercio electrónico que soporta 146 millones de suscriptores que manejan 2.500 millones de transacciones al año.</p>
                            <p> <strong>Walmart Canada</strong> reconstruyó toda su aplicación web y pila móvil como un sistema Reactivo y vio un aumento del 20 por ciento en la conversión a ventas de tráfico web y un aumento del 98 por ciento en los pedidos móviles recortando los tiempos de carga de páginas en más de un tercio. </p>
                            <p>En <strong>Tenea</strong>, empresa que se dedica a implantar soluciones de negocio a través de las nuevas tecnologías, están trabajando hace más de 5 años con tecnologías como ActiveMQ, RabittMQ, Fuse Enterprise (componentes OSGI), mongoDB, ElasticSearch o Solr y, por supuesto, en orientación a eventos y en programación reactiva. Concretamente, en su motor de reglas IoT TeneaRules, que han miniaturizado para que corra sobre hardware de dominio público low cost (TP-Llink, Xiaomi), sobre el open source OpenWrt y cuya sintaxis declarativa y funcional les permite programar comportamientos asociados a los eventos del entorno: ES_DE(NOCHE)= , ALARMA(ON)= ; PUERTA,PRINCIPAL(ABIERTA)=, etc. </p>
                            <p><strong>Jafar Husain</strong>, Desarrollador Senior en el equipo de Interfaz de Usuario de TV en <strong> Netflix</strong> comenta lo siguiente:<br>
                                <cite>"Over the last year, Netflix has reinvented our client-server interaction model. One of the key building blocks of our platform is Microsoft’s open-source Reactive Extensions library (Rx). Netflix is a big believer in the Rx model, because Rx has made it much easier for us to build complex asynchronous programs."</cite>
                            </p>
                            <p>Husain También menciona que actualmente Netflix es de las pocas compañías que utiliza la programación reactiva tanto en el servidor como en el cliente, sin embargo, no son la única: <strong> Felipe Lima</strong>, Miembro del equipos de desarrollo de Android en <strong>Airbnb</strong>, menciona por qué decidieron inclinarse hacia la programación reactiva mediante RxJava:<br> <cite >" It’s easy to switch back and forth between threads. It’s built right into the framework, Async can be very cumbersome and error-prone, and RxJava is one reason we you don’t need to do that anymore, and why you can compose different tasks together".</cite> </p>

                            <p>La programación reactiva se ha aplicado durante varios años en el <a href="http://reactivex.io/"><strong>Front-end</strong></a> Mediante el uso de cambios de estado en los diferentes componentes <a href="https://dev.to/petyosi/reactive-programming-for-react-developers-the-absolute-beginner-guide-5eeg">Reactive Programming for React Developers</a></p>
                            <center><a href="http://reactivex.io/" data-rel="frontend"><img src="images/frontend.PNG" alt="Frontend en Reactivex" class="img-responsive img-thumbnail"></a>
                                <figcaption>Uno de los principales usos de Recativex</figcaption>
                            </center>


                        </div>
                        <div class="col-md-6">
                            <strong>Algunas compañías que hacen uso de este Paradigma en sus productos:</strong>
                            <center><a href="http://reactivex.io/" data-rel="frontend"><img src="images/compañias.PNG" alt="Compañias que usan RecativeX" class="img-responsive img-thumbnail"></a>
                                <figcaption>Compañías como Netflix y Microsoft han apostado a este paradigma</figcaption>
                            </center>

                            <strong>Fase monolito y evolución en la industria</strong>

                            <p>Tras un periodo de desarrollo de software, la empresa dispondrá de una plataforma que crecerá hasta donde el éxito le acompañe, incrementando la complejidad del ya sofisticado entorno. Tanto si la plataforma es Java, C#, PHP, Python o Perl, el desarrollo corre el riesgo de convertirse en un monolito difícil de mantener y evolucionar. Los procesos inicialmente simples tienden a cubrir cada vez más variantes, en función de las necesidades definidas por Dirección, Marketing o el propio Product Owner.</p>

                            <p>En una situación como esta la solución más adoptada por los Arquitectos de Desarrollo es la de evolucionar hacia una arquitectura:</p>

                            <ul>
                                <li>    1.  Orientada a servicios. Cada servicio es una función sin estado que recibe una llamada y devuelve una respuesta.</li>

                                <li>    2.  Orientada a microservicios. Es una evolución de la orientación a servicios. Como en el caso anterior los microservicios están coordinados a través de la ORQUESTACIÓN.</li>

                                <li>    3.  Reactiva, funcional y orientada a microservicios, pero coordinados por COREOGRAFIA, y con la inferencia basada en eventos de negocio.</li>
                            </ul>

                            <strong>Arquitectura Reactiva Funcional</strong>

                            <p>La arquitectura reactiva funcional es aquella en la que la inferencia son los EVENTOS. En este caso no hablamos de eventos de sistema, como los subsistemas de ventanas de los entornos gráficos (X11, Windows o Gnome), sino por eventos de negocio.</p>
                            <p>La reactividad ha aparecido no solo en la parte servidora: Spring, Vert.x, ya que afecta a la arquitectura de ejecución, sino que ha entrado para instalarse de forma definitiva en la parte cliente con implementaciones en Javascript: Reactjs liberada por Facebook al mundo open, Bacon.js o RxJS.</p>
                            <p>La importancia para las empresas radica en que se puede crear funcionalidad a partir de cualquier evento que se genere: alta_cliente, baja_cliente, venta_producto, así como la gestión de las operaciones: rotura_stock, paquetes_fuera_stock_minimo, alta_empleado, fin_promocion, envio_urgente, etc.</p>
                            <p>Esto permitirá interceptar el flujo de datos, crear bases de datos/registros y/o funcionalidades que multiplican las capacidades digitales de la empresa, creando una nueva especie de empresas más flexibles, más adaptadas a los nuevos escenarios y, por tanto, más competitivas.</p>

                            <p>La solución, que ya documentan empresas como <strong>Nginx</strong> y otros fabricantes, es evolucionar de aplicaciones MONOLITO a microservicios reactivos y funcionales con un roadmap bien definido, que acople el día a día de la empresa con la introducción de la arquitectura reactiva que ya usan empresas como <strong>Netflix</strong> u otras muchas.</p>

                            <p>En definitiva, ya estamos en el momento de marcar el rumbo hacia estas nuevas herramientas y entornos de desarrollo.</p>

                            <strong>Aplicación en el backend: manejo de back-pressure</strong>

                            <p>Se dice que existe <strong>back-pressure</strong> cuando una aplicación no es capaz de soportar una gran cantidad de datos por falta de recursos, la mayoria de veces este problema esta relacionado a la velocidad computacional (Se procesando las entradas mas rapido que las salidas), la programación reactiva ayuda a manejar este problema notificando al servicio que nos esta enviando datos cuando el servicio que los recibe se queda sin recursos.</p>

                            <strong>Aplicación en interoperabilidad</strong>

                            <p>El patrón Observer y los sistemas de suscripción y dispatchers son excepcionales en el manejo de mensajes de interoperabilidad entre sistemas y componentes de un mismo sistema</p>

                            <p>Los mayores exponentes de esto son:</p>
                        
                            <ul>
                                <li><strong>Websockets:</strong> protocolo de suscripción a mensajes entre un servidor emisor y una aplicacion o componente receptor cuando hay mensajes para enviar en lugar de un polling por parte del receptor.</li>
                                <li><strong>Server-side events:</strong> protocolo de suscripción en el cual un servidor central envia mensajes al generarse un evento dentro de este con el cual realiza un broadcast a los suscritos.</li>
                            </ul>
                            
                            <strong>¿Cuando usar la programación reactiva?</strong>

                            <p>De manera general, la programación reactiva se implementa cuando una aplicación maneje un gran flujo de datos o tenga muchas fuentes de datos y que requiera de alguna manera la propagación de cambio en datos modulos y eventos., sin la programación reactiva estas aplicaciones pueden tener problemas relacionados a la sincronización de los datos y como se muestran en la interfaz grafica. Es comun usar la programación reactiva a la par con la programación orientada a objetos en casos donde la programación asincróna se vuelve dificil de entender y mantener. Es importante mencionar la concurrencia, tema en el cual partes de un programa son ejecutadas con cierta regularidad en desorden o en un orden parcial, estos se pueden comunicar entre ellos mientras se estan ejecutando, con la programación reactiva se mejora la concurrencia de las aplicaciones creando modelos asíncrono, no bloqueantes.</p>

                            <strong>Testing de Software</strong>

                            <p><b>Mocks y Stubs Reactivos:</b> En lugar de utilizar mocks tradicionales que imitan comportamientos estáticos, 
                                se pueden emplear mocks reactivos que emulen flujos de eventos dinámicos. Esto permite simular condiciones reales 
                                y complejas de manera más cercana.</p>

                            <p><b>Testing de Streams y Flujos de Datos:</b> Dado que la FRP se centra en la manipulación de flujos de datos continuos, 
                                es útil para probar cómo los programas reaccionan a cambios en estos flujos. Los frameworks y herramientas diseñados para FRP
                                 facilitan la creación y manipulación de estos flujos durante el testing.</p>

                            <p><b>Propiedades y Leyes de Comportamiento:</b> La FRP promueve el diseño de programas en términos de propiedades y leyes de 
                                comportamiento, en lugar de pruebas unitarias tradicionales. Esto facilita la especificación y verificación de comportamientos
                                 complejos a lo largo del tiempo.</p>

                            <p><b>Testing de Interacciones Complejas:</b> En aplicaciones donde múltiples eventos y estados deben coordinarse de manera precisa,
                                 la FRP proporciona herramientas para modelar y verificar estas interacciones de manera declarativa y concisa.</p>

                            <p><b>Simulación de Entornos Dinámicos:</b> Al simular entornos dinámicos y eventos impredecibles, la FRP puede ayudar a asegurar que
                                 los programas reaccionen de manera correcta y predecible ante situaciones reales.</p>


                            <strong>Algunos casos de uso moderno</strong>

                            <ul>
                                <li>    - Aplicaciones de IOT en donde se crean eventos que luego controlan procesos reales o transacciones de negocios.</li>

                                <li>    - Aplicaciones que recogen y monitorean elementos de datos o actividades de una red.</li>

                                <li>    - Aplicaciones que requieran alta interacción usuario-a-usuario donde cada acción debe ser procesada e interpretada como lo son los videojuegos o las redes sociales.</li>

                                <li>    - Comunicación entre aplicaciones, particularmente que realicen analisis estadistico que monitoree cambios y realize eventos al detectar estos cambios.</li>

                            </ul>

                        </div>
                    </div>
                    <!-- end row -->
                </section>
                <!-- end section -->
                <section id="line10" class="section">
                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Referencias<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->
                    <div class="row">
                        <div class="col-md-12">





                            <ul>
                                <li>1. <a href="http://reactivex.io/languages.html">ReactiveX</a></li>
                                <li>2. <a href="https://colab.research.google.com/drive/19SeUjUM_AYaxhGB-qintY822lC9NO1La?usp=sharing">Codigo RxPY</a> </li>
                                <li>3. <a href="https://www.tutorialspoint.com/rxpy/rxpy_quick_guide.htm">Mas Ejemplos RxPy</a></li>
                                <li>4. <a href="https://www.baeldung.com/rx-java">RxJava</a></li>
                                <li>5. <a href="https://www.toptal.com/android/functional-reactive-android-rxjava">RxJava Android</a></li>
                                <li>6. <a href="https://www.amazon.com/-/es/Luca-Mezzalira-ebook/dp/B077GCMHNS">Front-End Reactive Architectures de Luca Mezzalira</a></li>
                                <li>7. <a href="https://go.lightbend.com/reactive-microservices-architecture-design-principles-for-distributed-systems-oreilly">Reactive Microservices Architecture de Jonas Bonér</a></li>
                                <li>8. <a href="https://www.amazon.es/Reactive-Systems-Architecture-Jan-Machacek/dp/1491980710">Reactive Systems Architecture de Jan Machacek, Martin Zapletal, Michal Janousek , Anirvan Chakraborty</a></li>
                                <li>9. <a href="https://podcasts.apple.com/tt/podcast/reactive-architecture-patterns-debate/id1487784619?i=1000460072673&l=fr">GSAS: Reactive Architecture Patterns Debate</a></li>
                                <li>10. <a href="https://www.youtube.com/watch?v=OPhQvG1-32k">What is a Reactive Application? • Panel Debate</a></li>
                                <li>11. <a href="https://www.youtube.com/watch?v=RuHkNGrwD5o">Reactive Systems: 21st Architecture for 21st Century Systems by Dave Farley</a></li>
                                <li>12. <a href="https://refactoring.guru/es/design-patterns/observer">Patrón Observer</a></li>
                                <li>13. <a href="https://profile.es/blog/que-es-la-programacion-reactiva-una-introduccion/#:~:text=La%20programaci%C3%B3n%20reactiva%20es%20un,o%20infinitos%20de%20manera%20as%C3%ADncrona.&text=Orientados%20a%20mensajes%3A%20minimizan%20el,de%20mensajes%20de%20manera%20as%C3%ADncrona">¿Qué es la programación reactiva? Una introducción</a></li>
                                <li>14. <a href="https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems">Reactive Programming versus Reactive Systems | White Paper | Lightbend</a></li>
                                <li>15. <a href="https://developer.ibm.com/articles/defining-the-term-reactive/">Defining the term 'reactive'</a></li>
                                <li>16. <a href="https://dzone.com/articles/what-are-reactive-streams-in-java">What Are Reactive Streams in Java?</a></li>
                                <li>17. <a href="https://spring.io/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape">Notes on Reactive Programming</a></li>
                                <li>18. <a href="https://akarnokd.blogspot.com/2016/03/operator-fusion-part-1.html">Generations of reactive classification</a></li>
                                <li>19. <a href="https://itnext.io/demystifying-functional-reactive-programming-67767dbe520b">Demystifying Functional Reactive Programming</a></li>
                            </ul>

                        </div>
                    </div>
                    <!-- end row -->
                </section>
                <!-- end section -->

                <!-- end section -->
            </div>
            <!-- // end .col -->
        </div>
        <!-- // end .row -->
    </div>
    <!-- // end container -->
</div>
<!-- end wrapper -->
<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/retina.js"></script>
<script src="js/jquery.fitvids.js"></script>
<script src="js/wow.js"></script>
<script src="js/jquery.prettyPhoto.js"></script>
<!-- CUSTOM PLUGINS -->
<script src="js/custom.js"></script>
<script src="js/main.js"></script>
<script src="js/syntax-highlighter/scripts/shCore.js"></script>
<script src="js/syntax-highlighter/scripts/shBrushXml.js"></script>
<script src="js/syntax-highlighter/scripts/shBrushCss.js"></script>
<script src="js/syntax-highlighter/scripts/shBrushJScript.js"></script>
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.0.1/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>
